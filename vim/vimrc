se encoding=utf-8
scripte utf-8
se autoread
se background=dark
se backspace=indent
se belloff=backspace,cursor,error,showmatch,esc visualbell
se showbreak= breakindent breakindentopt=shift:2 cpoptions+=n
se ignorecase smartcase
se casemap=keepascii
se clipboard=unnamed,unnamedplus
se colorcolumn=+1
se completeopt=menu,menuone,preview
se cursorline
se diffopt=filler,vertical,closeoff
se display=lastline
se fileencodings=ucs-bom,utf-8,default,euc-jp,cp932
se fileformats=unix,dos
se fillchars=vert:│,fold:-
se guioptions=!Mr
se formatoptions+=mBj
se guicursor=a:blinkon0
se helplang=Ja,En
se history=1000
se smartindent autoindent
se keywordprg=:Man
se lispwords-=if
se list listchars=tab:»-,extends:»,precedes:«,nbsp:◦
se showmatch matchtime=1 matchpairs+=（:）,｛:｝,＜:＞,［:］,「:」,『:』,【:】
se modeline modelines=3
se mouse=a mousemodel=extend nomousehide
se number relativenumber
se pastetoggle=<F10>
se path+=include,arch/x86/include
se pumheight=10
se report=15
se runtimepath+=/usr/share/vim/addons
se scrolloff=3 sidescroll=1 sidescrolloff=10
se incsearch hlsearch nowrapscan
if has('win32') && !has('gui_win32')
	se shell=pwsh
endif
se shortmess=aoOtT
se splitbelow splitright
se suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc,.exe,.lock
se suffixesadd=.tex
se laststatus=2
fu! g:Statusline()
	return '%f%<%H'
		\ .. (&modified ? ' +' : '')
		\ .. (!&modifiable ? ' -' : '')
		\ .. (&readonly ? ' RO' : '')
		\ .. (&paste ? ' <paste>' : '')
		\ .. '%='
		\ .. (&bomb ? toupper(&fileencoding) .. '-BOM'
		\	: &fileencoding !=# 'utf-8' ? toupper(&fileencoding) : '')
		\ .. (&fileformat ==# 'unix' ? ''
		\	: &fileformat ==# 'dos' ? ' CRLF' : ' CR')
		\ .. ' %Y 0x%02.4B %5l,%3c-%-3v %P %LL'
		\ .. (wordcount().chars - line('$'))
		\ .. 'C'
endfu
se statusline=%{%Statusline()%}
se showtabline=2
fu! s:Tablabel(tabpagenr)
	let l:buflist = tabpagebuflist(a:tabpagenr)
	let l:curbufnr = l:buflist[tabpagewinnr(a:tabpagenr) - 1]
	let l:hi = a:tabpagenr ==# tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
	let l:no = len(l:buflist) ==# 1 ? '' : len(l:buflist)
	let l:mod = len(filter(copy(l:buflist), 'getbufvar(v:val, "&modified")')) ? '+' : ''
	let l:sp = (l:no .. l:mod) ==# '' ? '' : ' '
	let l:fname = fnamemodify(bufname(l:curbufnr), ':t')
	let l:fname = l:fname ==# '' ? '_' : l:fname
	return '%' .. a:tabpagenr .. 'T%#Title#' .. l:no .. l:hi .. l:mod .. l:sp .. l:fname .. '%#TabLineFill#'
endfu
fu! g:Cuitabline()
	let l:tablabels = join(map(range(1, tabpagenr('$')), '<SID>Tablabel(v:val)'), ' ')
	let l:info = '%#TabLine#%<' .. fnamemodify(getcwd(), ':~') .. ' '
	return l:tablabels .. ' %T%=' .. l:info
endfu
se tabline=%!g:Cuitabline()
se noexpandtab shiftwidth=0 tabstop=8
se tagcase=match tags=./tags;./../../,tags;../../
se ttimeoutlen=10
let $MYVIM = fnamemodify($MYVIMRC, ':h')
se viminfofile=$MYVIM/.viminfo directory=$MYVIM/swap
se virtualedit=block
se wildmenu wildignorecase wildmode=list:longest,full
se wrap
let g:c_comment_strings = 1
let g:c_gnu = 1
let g:c_syntax_for_h = 1
let g:is_bash = 1
let g:mapleader = ' '
let g:maplocalleader = ' '
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', 'c', 'cpp']
let g:ocaml_revised = 1
let g:python_highlight_all = 1
let g:readline_has_bash = 1
let g:rust_bang_comment_leader = 1
let g:tex_conceal = ''
let g:tex_flavor = 'latex'
let g:vim_indent_cont = &tabstop
let g:vim_json_conceal = 0

if &term ==# 'xterm' || has('win32')
	se t_Co=256
endif

fu! s:Passthrough(seq)
	return "\ePtmux;" .. substitute(a:seq, "\e", "\e\e", 'g') .. "\e\\"
endfu
if !exists('$TMUX')
	fu! s:Passthrough(seq)
		return a:seq
	endfu
endif
let &t_SI ..= s:Passthrough("\e[<r")
let &t_EI ..= s:Passthrough("\e[<s\e[<0t")
let &t_te ..= s:Passthrough("\e[<0t\e[<s")

fu! s:CopyOSC52(list)
	call echoraw("\e]52;c;" .. base64_encode(str2blob(a:list)) .. "\x7")
endfu

" mapping
map Y y$

nno <silent> mm <Cmd>noh<CR>

nno <silent> <C-W><C-E> <Cmd>tabe<CR>
nno <silent> <C-W><C-L> <Cmd>tabn<CR>
nno <silent> <C-W><C-H> <Cmd>tabp<CR>
nno <silent> <C-W><C-O> <Cmd>tabo<CR>
tno <silent> <C-W><C-E> <Cmd>tabe<CR>
tno <silent> <C-W><C-L> <Cmd>tabn<CR>
tno <silent> <C-W><C-H> <Cmd>tabp<CR>
tno <silent> <C-W><C-O> <Cmd>tabo<CR>

nno <silent> <Leader>o o<Esc>

nno Q gq
nno <Leader>w <Cmd>w<CR>
nno <Leader>n <Cmd>n<CR>
nno <Leader>p <Cmd>N<CR>
nno <Leader>c <Cmd>clo<CR>

nma ysa' ys2i'
nma ysa" ys2i"
nma ysa` ys2i`

nno <Esc>M <C-W>-
nno <Esc>P <C-W>+

cno <C-G> <C-\><C-N>
ino <C-G> <C-\><C-N>

nno g/ /\<\><Left><Left>

if has('win32')
	sil! vun <C-X>
endif

ino <C-U> <C-G>u<C-U>

cno <Left> <Space><BS><Left>
cno <Right> <Space><BS><Right>
cno <C-P> <Up>
cno <C-N> <Down>
cno <Up> <C-P>
cno <Down> <C-N>
cno <C-A> <Home>
" cno <C-O>
" cno <C-B>

fu! s:FixWhitespace(line1, line2)
	let l:save_cursor = getcurpos()
	sil! exe 'keeppatterns ' .. a:line1 .. ',' .. a:line2 .. 's/\\\@<!\s\+$//'
	call setpos('.', l:save_cursor)
endfu
com! -range=% FixWhitespace call <SID>FixWhitespace(<line1>, <line2>)
nno <silent> <Leader>f <Cmd>FixWhitespace<CR>

com! -nargs=0 Cdhere tcd %:p:h
nno <silent> <Leader>d <Cmd>Cdhere<CR>
fu! s:Cdcword()
	let l:cword = expand('<cWORD>')
	exe 'tcd ' .. l:cword
endfu
com! -nargs=0 Cdcword call <SID>Cdcword()
nno <silent> <Leader>D <Cmd>Cdcword<CR>

fu! s:ResetSearchDirection(cmd)
	let @/=@/
	nun n
	nun N
	return a:cmd
endfu
fu! s:ConsistentSearch(cmd)
	nno <expr> n <SID>ResetSearchDirection('n')
	nno <expr> N <SID>ResetSearchDirection('N')
	return a:cmd
endfu
nno <expr> ?  <SID>ConsistentSearch('?')
nno <expr> #  <SID>ConsistentSearch('#')
nno <expr> g# <SID>ConsistentSearch('g#')

fu! s:Search(zero)
	let l:cword = expand('<cword>')
	if a:zero ==# 0
		let l:pat = '\<' .. l:cword .. '\>'
	else
		let l:pat = l:cword
	endif
	call histadd('/', l:pat)
	let @/=l:pat
	call <SID>CopyOSC52([l:cword])
	return "\"_yiw\<BS>\<C-\>\<C-N>n"
endfu
nno <expr> *  <SID>Search(0)
nno <expr> g* <SID>Search(1)

fu! g:RestoreRegister()
	sil! let @* = s:restore_reg
	sil! let @+ = s:restore_reg
	let @" = s:restore_reg
	return ''
endfu
fu! s:Repl()
	sil! let s:restore_reg = @*
	sil! let s:restore_reg = @+
	let s:restore_reg = @"
	return "p@=g:RestoreRegister()\<CR>"
endfu
vno <silent> <expr> p <SID>Repl()

fu! s:Getfname()
	let l:fname = bufname() .. ':' .. getcurpos()[1]
	sil! let @* = l:fname
	sil! let @+ = l:fname
	call <SID>CopyOSC52([l:fname])
	return l:fname
endfu
com! Getfname echo <SID>Getfname()
nno <silent> yd <Cmd>Getfname<CR>

fu! s:RegexRubout(re)
	let l:right = strpart(getcmdline(), getcmdpos() - 1)
	let l:left = strpart(getcmdline(), 0, getcmdpos() - 1)
	let l:left = substitute(l:left, a:re, '', '')
	call setcmdpos(strlen(l:left) + 1)
	return l:left .. l:right
endfu
cno <Esc>/     <C-\>e<SID>RegexRubout('\v[^/ ]*/? *$')<CR>
cno <C-W>      <C-\>e<SID>RegexRubout('\v([a-zA-Z0-9]+\|[^ a-zA-Z0-9]+) *$')<CR>
cno <Esc>h     <C-\>e<SID>RegexRubout('\v([a-zA-Z0-9]+\|[^ a-zA-Z0-9]+) *$')<CR>
cno <Esc><C-W> <C-\>e<SID>RegexRubout('\v[^ ]* *$')<CR>

fu! s:MultiHlSetup()
	hi Multihl1 ctermbg=14 ctermfg=8 guibg=#00ffff guifg=#808080
	hi Multihl2 ctermbg=13 ctermfg=8 guibg=#ff00ff guifg=#808080
	hi Multihl3 ctermbg=11 ctermfg=8 guibg=#ffff00 guifg=#808080
	hi Multihl4 ctermbg=1  ctermfg=7 guibg=#800000 guifg=#c0c0c0
	hi Multihl5 ctermbg=4  ctermfg=7 guibg=#000080 guifg=#c0c0c0
	hi Multihl6 ctermbg=2  ctermfg=7 guibg=#008000 guifg=#c0c0c0
endfu
fu! s:Hi(num, ...)
	if a:num ==# 0
		for l:num in range(1, 6)
			sil! call matchdelete(l:num + 5)
		endfor
	else
		sil! call matchdelete(a:num + 5)
		if a:0 !=# 0
			call matchadd('Multihl' .. a:num, a:1, 10, a:num + 5)
			call histadd(':', 'Hi' .. a:num .. ' ' .. a:1)
			return
		endif
	endif
	call histadd(':', 'Hi' .. a:num)
endfu
com! -nargs=0 Hi0 call <SID>Hi(0)
com! -nargs=? Hi1 call <SID>Hi(1, <f-args>)
com! -nargs=? Hi2 call <SID>Hi(2, <f-args>)
com! -nargs=? Hi3 call <SID>Hi(3, <f-args>)
com! -nargs=? Hi4 call <SID>Hi(4, <f-args>)
com! -nargs=? Hi5 call <SID>Hi(5, <f-args>)
com! -nargs=? Hi6 call <SID>Hi(6, <f-args>)
nno <Leader>0 :<C-U>Hi0<CR>
nno <Leader>1 :<C-U>Hi1 <C-R><C-W><CR>
nno <Leader>2 :<C-U>Hi2 <C-R><C-W><CR>
nno <Leader>3 :<C-U>Hi3 <C-R><C-W><CR>
nno <Leader>4 :<C-U>Hi4 <C-R><C-W><CR>
nno <Leader>5 :<C-U>Hi5 <C-R><C-W><CR>
nno <Leader>6 :<C-U>Hi6 <C-R><C-W><CR>

fu! s:FontSizeSet(amount)
	call echoraw(s:Passthrough("\e]7770;" .. a:amount .. "\x7"))
endfu
fu! s:FontSizeGet()
	let l:ret = ""
	call <SID>FontSizeSet('?')
	while 1
		let l:c = getcharstr()
		let l:ret ..= l:c
		if l:c ==# "\x7"
			break
		endif
	endwhile
	echo l:ret[7:-2]
endfu
com! FontSizeGet call <SID>FontSizeGet()
com! FontSizeReset call <SID>FontSizeSet('')
nno <silent> <Esc>=              <Cmd>call <SID>FontSizeSet('')<CR>
nno <silent> <Esc>+              <Cmd>call <SID>FontSizeSet('+1')<CR>
nno <silent> <Esc>-              <Cmd>call <SID>FontSizeSet('-1')<CR>
nno <silent> <C-ScrollWheelUp>   <Cmd>call <SID>FontSizeSet('+1')<CR>
nno <silent> <C-ScrollWheelDown> <Cmd>call <SID>FontSizeSet('-1')<CR>

fu! s:TagfuncLinux(pattern, flags, info)
	if !get(b:, 'guesstag', 1) | let b:guesstag = 1 | return v:null | endif

	let l:cmdline = 0
	if a:flags ==# 'c'
		let l:pat = '^' .. a:pattern .. '$'
		let l:path = a:info['buf_ffname'][len(fnamemodify(tagfiles()[0], ':p:h')) + 1:]
	elseif a:flags ==# ''
		let l:pat = '^' .. a:pattern .. '$'
		let l:path = '<command line>'
		let l:cmdline = 1
	elseif a:flags ==# 'r'
		let l:pat = a:pattern
		let l:path = '<command line>'
		let l:cmdline = 1
	else " 'i'
		let l:pat = '^' .. a:pattern
		let l:path = a:info['buf_ffname'][len(fnamemodify(tagfiles()[0], ':p:h')) + 1:]
	endif
	echom 'tag: ' .. l:pat .. ' from ' .. l:path

	" Exclude prototypes
	let l:tags = filter(taglist(l:pat), 'get(v:val, ''kind'', '''') !=# ''p''')
	if len(l:tags) ==# 1 | echom '  Jump to the only' | return l:tags | endif

	" Limit to members or non-members
	let l:before = expand('<cexpr>')[:-1 - len(expand('<cword>'))]
	if l:before[-1:] ==# '.' || l:before[-2:] ==# '->'
		echom '  Only members'
		call filter(l:tags, 'get(v:val, ''kind'', '''') ==# ''m''')
	else
		echom '  Exclude members'
		call filter(l:tags, 'get(v:val, ''kind'', '''') !=# ''m''')
	endif
	if len(l:tags) ==# 1 | echom '  Jump to the only' | return l:tags | endif

	" Exclude unlikelies
	let l:exclude_path_list = ['tools', 'drivers', 'samples', 'scripts']
	if l:path[:5] ==# 'tools/'
		call remove(l:exclude_path_list, 0)
	elseif l:path[:7] ==# 'drivers/'
		call remove(l:exclude_path_list, 1)
	elseif l:path[:7] ==# 'samples/'
		call remove(l:exclude_path_list, 2)
	elseif l:path[:7] ==# 'scripts/'
		call remove(l:exclude_path_list, 3)
	endif
	let l:exclude_pat = join(l:exclude_path_list, '|')
	echom '  Exclude ' .. l:exclude_pat .. ' dir'
	call filter(l:tags, 'v:val[''filename''] !~# ''\v^(' .. l:exclude_pat .. ')/''')
	if len(l:tags) ==# 1 | echom '  Jump to the only' | return l:tags | endif

	" Guessing
	if l:cmdline | return l:tags | endif
	let l:current = filter(copy(l:tags), 'l:path ==# v:val[''filename'']')
	if len(l:current) ==# 1 | echom '  Jump to the only current' | return l:current | endif

	" Failed guessing, return likelies
	return l:tags
endfu
fu! s:SetTagfunc()
	if fnamemodify(get(tagfiles(), 0, '/'), ':p') =~# '/linux/'
		setl tagfunc=<SID>TagfuncLinux
	endif
endfu
fu! s:Tjump(sp, guess)
	if len(tagfiles())
		let b:guesstag = a:guess
		return (a:sp ? "\<C-W>" : '') .. "g\<C-]>"
	else
		return ":ALEGoToDefinition" .. (a:sp ? ' -split' : '') .. "\<CR>"
	endif
endfu
nno <expr> g<C-]>      <SID>Tjump(0, 0)
vno <expr> g<C-]>      <SID>Tjump(0, 0)
nno <expr> g]          <SID>Tjump(0, 0)
vno <expr> g]          <SID>Tjump(0, 0)
nno <expr> <C-]>       <SID>Tjump(0, 1)
vno <expr> <C-]>       <SID>Tjump(0, 1)
nno <expr> <C-W>g<C-]> <SID>Tjump(1, 0)
vno <expr> <C-W>g<C-]> <SID>Tjump(1, 0)
nno <expr> <C-W>g]     <SID>Tjump(1, 0)
vno <expr> <C-W>g]     <SID>Tjump(1, 0)
nno <expr> <C-W><C-]>  <SID>Tjump(1, 1)
vno <expr> <C-W><C-]>  <SID>Tjump(1, 1)
nno <expr> <C-W>]      <SID>Tjump(1, 1)
vno <expr> <C-W>]      <SID>Tjump(1, 1)
com! -nargs=1 -bar Gtj  let b:guesstag = 0 | tj  <args>
com! -nargs=1 -bar Gstj let b:guesstag = 0 | stj <args>

fu! s:Spacing(line1, line2)
	let l:a = '[[:graph:]]'
	let l:m = '[^ [:graph:][:cntrl:]]'
	let l:k = '[、。]'
	let l:s = 'keeppatterns ' .. a:line1 .. ',' .. a:line2 .. 's/\v'

	sil! exe l:s..'('..l:a..'+) +\ze'..l:a..'/\1 /g'
	sil! exe l:s..'('..l:a..'+) *\ze'..l:m..'/\1 /g'
	sil! exe l:s..'('..l:m..'+) *\ze'..l:a..'/\1 /g'

	sil! exe l:s..'('..l:m..'+) +\ze'..l:m..'/\1/g'
	sil! exe l:s..'('..l:a..'+) +\ze'..l:k..'/\1/g'
	sil! exe l:s..'('..l:k..'+) +\ze'..l:a..'/\1/g'

	sil! exe l:s..'('..l:m..'+) +\ze[)]/\1/g'
	sil! exe l:s..'([(]) +\ze('..l:m..'+)/\1/g'

	sil! exe l:s..' +$//g'
endfu
com! -range=% Spacing call <SID>Spacing(<line1>, <line2>)
nno <silent> <Leader>s :call <SID>Spacing('.', '.')<CR>
vno <silent> <Leader>s :call <SID>Spacing('''<', '''>')<CR>

fu! s:UnSpacing(line1, line2)
	let l:a = '[[:graph:]]'
	let l:m = '[^ [:graph:][:cntrl:]]'
	let l:s = 'keeppatterns ' .. a:line1 .. ',' .. a:line2 .. 's/\v'

	sil! exe l:s..'('..l:a..'+) +\ze'..l:a..'/\1 /g'

	sil! exe l:s..'('..l:a..'+) +\ze'..l:m..'/\1/g'
	sil! exe l:s..'('..l:m..'+) +\ze/\1/g'

	sil! exe l:s..' +$//g'
endfu
com! -range=% Unspacing call <SID>UnSpacing(<line1>, <line2>)
nno <silent> <Leader>S :call <SID>UnSpacing('.', '.')<CR>
vno <silent> <Leader>S :call <SID>UnSpacing('''<', '''>')<CR>

fu! s:CopyMode()
	if !exists('w:copymode')
		let w:copymode = 1
		setl nolist nonumber norelativenumber nobreakindent
	else
		unlet w:copymode
		setl list number relativenumber breakindent
	endif
endfu
com! CopyMode call <SID>CopyMode()
nno <silent> <Leader>v <Cmd>call <SID>CopyMode()<CR>

fu! s:OpenEmpty()
	if !get(b:, 'openempty_active', 0)
		let b:save_openempty = [&comments, &indentexpr, &autoindent, &smartindent]
		setl comments= indentexpr= noautoindent nosmartindent
		let b:openempty_active = 1
	else
		let [&comments, &indentexpr, &autoindent, &smartindent] = b:save_openempty
		let b:openempty_active = 0
	endif
endfu
nno <silent> go <Cmd>call <SID>OpenEmpty()<CR>o<Cmd>call <SID>OpenEmpty()<CR>

" excommand
com! DiffOrig vert new | se bt=nofile | r ++edit # | 0d_ | difft | winc p | difft
com! Hitest ru syntax/hitest.vim
com! Colortest ru syntax/colortest.vim

fu! s:XXD()
	if !exists('b:save_ft_binary')
		let b:save_ft_binary = [&filetype, &binary]
		let &binary = 1
		sil e " for binary to take effect
		let &ft = 'xxd'
		%!xxd
	else
		let [&filetype, &binary] = b:save_ft_binary
		unlet b:save_ft_binary
		%!xxd -r
	endif
endfu
com! XXD call <SID>XXD()

fu! s:Align(cmd, line1, line2, ...)
	let l:save_cursor = getcurpos()
	if a:0 ==# 0
		let l:char = input('')
	else
		let l:char = a:1
	endif
	exe 'normal ' .. a:line1 .. 'GV' .. a:line2 .. 'G' .. a:cmd .. l:char
	call setpos('.', l:save_cursor)
endfu
com! -range -nargs=? AlignRight call <SID>Align('gL', <line1>, <line2>, <f-args>)
com! -range -nargs=? AlignLeft  call <SID>Align('gl', <line1>, <line2>, <f-args>)

com! -nargs=0 Reload let s:undoreload = &undoreload | se undoreload=0 | e | let &undoreload = s:undoreload

fu! s:Nkf()
	if executable('uchardet')
		let l:cmd = 'uchardet'
	elseif executable('nkf')
		let l:cmd = 'nkf --guess=1 '
	else
		echoe 'uchardet or nkf must be installed!'
		return
	endif
	exe 'e ++enc=' .. system(l:cmd .. ' ' .. fnamemodify(expand('%'), ':p'))
endfu
com! -nargs=0 Nkf call <SID>Nkf()

fu! s:Command(env, reuse, focus, close, arg)
	let l:cmd = '/bin/bash -ic "' .. join(a:arg) .. '"'
	let l:opt = {'term_rows': &lines / 4, 'term_cols': &columns - 7, 'term_kill': 'term', 'env': a:env}
	if a:close
		let l:opt['term_finish'] = 'close'
	endif
	if a:reuse
		let l:n = bufnr('!' .. l:cmd)
		if l:n !=# -1
			exe 'bdelete ' .. l:n
		endif
	endif
	call term_start(l:cmd, l:opt)
	if !a:focus
		winc p
	endif
endfu
fu! s:BashComp(ArgLead, CmdLine, CursorPos)
	return g:bash#complete(substitute(strpart(a:CmdLine, 0, a:CursorPos), '^\s*\a\+ ', '', ''))
endfu
fu! s:GitComp(ArgLead, CmdLine, CursorPos)
	return g:bash#complete(substitute(strpart(a:CmdLine, 0, a:CursorPos), '^\s*\a\+ ', 'git ', ''))
endfu
com! -nargs=* -complete=customlist,<SID>BashComp S call <SID>Command({}, 0, 0, 0, [<f-args>])
com! -nargs=* -complete=customlist,<SID>BashComp I call <SID>Command({}, 0, 1, 1, [<f-args>])
com! -nargs=* -complete=customlist,<SID>GitComp Git call <SID>Command({'GIT_PAGER': ''}, 1, 1, 0, ['git', <f-args>])
com! -nargs=* -complete=customlist,<SID>GitComp Gitpager call <SID>Command({}, 1, 1, 0, ['git', <f-args>])

let s:template = {
	\ 'c'     : ['#include <stdio.h>', '', 'int main(void)', '{', '	printf("Hello\n");', '	return 0;', '}'],
	\ 'go'    : ['package main', '', 'import "fmt"', '', 'func main() {', '	fmt.Println("Hello")', '}'],
	\ 'perl'  : ['#!/usr/bin/perl', 'use strict;', 'use warnings;'],
	\ 'python': '#!/usr/bin/env python3',
	\ 'sh'    : ['#!/bin/bash', 'set -euxo pipefail'],
	\ }
let s:template_after = {
	\ 'c' : 'call cursor(5, 2)',
	\ 'go': 'call cursor(6, 2)',
	\ '_' : 'call cursor(line(''$''), 1)',
	\ }
fu! s:Template()
	if !has_key(s:template, &ft) | return | endif
	call append(0, s:template[&ft])
	if getline('$') ==# ''
		$d _
	endif
	exe get(s:template_after, &ft, s:template_after['_'])
	echon ' Template loaded'
endfu
com! -nargs=0 Template call <SID>Template()

fu! s:Sort(pat)
	let l:save_reg = @a
	norm! gv"ay
	let @a = join(sort(split(eval('@a'), a:pat)), a:pat)
	norm! gv"ap
	let @a = l:save_reg
endfu
com! -range Sort call <SID>Sort(' ')
com! -range SortComma call <SID>Sort(', ')
com! -nargs=1 -range SortSep call <SID>Sort(<f-args>)

" autocommand
let s:show_trailing_ws = 1
let s:trailing_ws_pat = ['\\\@<!\s\+$', '\\\@<!\s\+\%#\@<!$']
fu! s:HlTrailingWs(toggle, mode)
	if a:toggle
		let s:show_trailing_ws = !s:show_trailing_ws
	endif
	sil! call matchdelete(4)
	if !s:show_trailing_ws | return | endif
	if !get(b:, 'show_trailing_ws', 1) | return | endif
	sil! call matchadd('TrailingWhiteSpace', s:trailing_ws_pat[a:mode], 10, 4)
endfu
com! Togglehltrailingwhitespaces call <SID>HlTrailingWs(1, 0)

let s:show_ideo_space = 1
fu! s:HlIdeoSpace(toggle)
	if a:toggle
		let s:show_ideo_space = !s:show_ideo_space
	endif
	sil! call matchdelete(5)
	if !s:show_ideo_space | return | endif
	sil! call matchadd('IdeographicSpace', '[\u3000]', 10, 5)
endfu
com! Togglehlideographicspace call <SID>HlIdeoSpace(1)

fu! s:CopyUnnamed()
	if v:event.regname ==# ''
		call <SID>CopyOSC52(v:event.regcontents)
	endif
endfu

let s:ignore_lastline = {'gitcommit': '', 'hgcommit': '', 'cvs': '', 'svn': ''}
fu! s:GoToLastLine()
	if line('''"') <= line('$') && !has_key(s:ignore_lastline, &ft)
		norm! g`"
	endif
endfu

" gui
if has('gui_running') && has('win32')
	se guifont=Consolas:h11
	se lines=30 columns=86
	let s:guifont_default_size = split(split(&guifont, '[^\\]\zs,')[0], '[^\\]\zs:')[1][1:]
	fu! s:FontSizeSet(amount)
		let l:font = split(split(&guifont, '[^\\]\zs,')[0], '[^\\]\zs:')
		let l:size = l:font[1][1:]
		if a:amount ==# ""
			let l:size = s:guifont_default_size
		else
			let l:size = eval(l:size .. a:amount)
			if l:size == 0
				let l:size = 1
			endif
		endif
		let l:font[1] = l:font[1][0] .. l:size
		let &guifont = join(l:font, ':')
	endfu
	fu! s:CopyOSC52(list)
	endfu

	nno <silent> <M-Space> <Cmd>simalt ~<CR>
	cno <M-/> <C-\>e<SID>RegexRubout('\v[^/\\]*(/\|\\)? *$')<CR>
	cno <M-w> <C-\>e<SID>RegexRubout('\v[^ ]* *$')<CR>
	nno <M-m> <C-W>-
	nno <M-p> <C-W>+
	nno <silent> <M-=> <Cmd>call <SID>FontSizeSet('')<CR>
	nno <silent> <M-+> <Cmd>call <SID>FontSizeSet('+1')<CR>
	nno <silent> <M--> <Cmd>call <SID>FontSizeSet('-1')<CR>
	nno <silent> <C-=> <Cmd>call <SID>FontSizeSet('')<CR>
endif

pa! matchit
pa! termdebug
pa! editorconfig
ru ftplugin/man.vim

" quickrun
nma <Leader>r <Plug>(quickrun)
let g:quickrun_config = {
	\ 'python': {
	\   'command': 'python3',
	\ },
	\ 'scheme': {
	\   'command': 'chezscheme',
	\   'exec': '%c --script %s',
	\ },
	\ '_': {
	\   'outputter/buffer/opener': 'botright new',
	\   'outputter/buffer/close_on_empty': 1,
	\   'runner': 'terminal',
	\ },
	\ }
" ale
nma <Leader>j <Plug>(ale_next)
nma <Leader>k <Plug>(ale_previous)
nma <Leader>h <Plug>(ale_detail)
nma <Leader>l <Plug>(ale_code_action)
fu! s:ImplCAPat(pat, data, items)
	if empty(a:items)
		echo 'No code actions received from server'
		return
	endif
	for [l:type, l:item] in a:items
		if l:item.title =~# a:pat
			call ale#codefix#ApplyLSPCodeAction(a:data, l:item)
			return
		endif
	endfor
	echo 'No "' .. a:pat .. '" code action'
endfu
fu! s:CAPat(pat)
	call ale#codefix#Execute(mode() is# 'v' || mode() is# "\<C-V>", function('s:ImplCAPat', [a:pat]))
endfu
nno <Leader>i <Cmd>call <SID>CAPat('^Import')<CR>
xma <Leader>i <Cmd>call <SID>CAPat('^Import')<CR>
nno <Leader>q <Cmd>call <SID>CAPat('^Qualify')<CR>
xma <Leader>q <Cmd>call <SID>CAPat('^Qualify')<CR>
fu! s:ALEFixOnSaveToggle(vartype, value)
	let l:new = a:value ==# -1 ? '!' .. get(eval(a:vartype .. ':'), 'ale_fix_on_save', 0) : a:value
	exe 'let ' .. a:vartype .. ':ale_fix_on_save = ' .. l:new
endfu
com! -bar ALEFixOnSaveToggle        call <SID>ALEFixOnSaveToggle('g', -1)
com! -bar ALEFixOnSaveToggleBuffer  call <SID>ALEFixOnSaveToggle('b', -1)
com! -bar ALEFixOnSaveEnable        call <SID>ALEFixOnSaveToggle('g', 1)
com! -bar ALEFixOnSaveEnableBuffer  call <SID>ALEFixOnSaveToggle('b', 1)
com! -bar ALEFixOnSaveDisable       call <SID>ALEFixOnSaveToggle('g', 0)
com! -bar ALEFixOnSaveDisableBuffer call <SID>ALEFixOnSaveToggle('b', 0)
com! -bar ALEEnableAll        ALEEnable | ALEFixOnSaveEnable
com! -bar ALEEnableAllBuffer  ALEEnableBuffer | ALEFixOnSaveEnableBuffer
com! -bar ALEDisableAll       ALEDisable | ALEFixOnSaveDisable
com! -bar ALEDisableAllBuffer ALEDisableBuffer | ALEFixOnSaveDisableBuffer
com! -bar WriteNoFix          ALEFixOnSaveDisableBuffer | w
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
let g:ale_linters = {
	\ 'asciidoc'  : ['vale'],
	\ 'c'         : [],
	\ 'cpp'       : [],
	"\ 'c'         : ['clangd'],
	"\ 'cpp'       : ['clangd'],
	\ 'go'        : ['govet', 'gopls'],
	\ 'mail'      : ['vale'],
	\ 'markdown'  : ['vale'],
	\ 'ocaml'     : ['ocamllsp'],
	\ 'python'    : ['pylsp'],
	\ 'rst'       : ['vale'],
	\ 'rust'      : ['analyzer', 'cargo'],
	\ 'sh'        : [],
	\ 'typescript': [],
	\ }
let g:ale_fixers = {
	\ 'c'         : [],
	\ 'cpp'       : [],
	"\ 'c'         : ['clang-format'],
	"\ 'cpp'       : ['clang-format'],
	\ 'go'        : ['gofmt', 'goimports'],
	\ 'ocaml'     : ['ocamlformat'],
	\ 'python'    : ['isort', 'yapf'],
	\ 'rust'      : ['rustfmt'],
	\ 'typescript': [],
	\ }
let g:ale_c_clangformat_style_option = '-n'
let g:ale_c_clangformat_use_local_file = 1
let g:ale_rust_cargo_use_clippy = executable('cargo-clippy')
let g:ale_completion_enabled = 1
let g:ale_fix_on_save = 1
let g:ale_hover_cursor = 0
let g:ale_lint_on_text_changed = 0
let g:ale_lint_on_insert_leave = 0
let g:ale_virtualtext_cursor = 0
if has('win32unix')
	let g:ale_enabled = 0
endif
" vim-surround
let g:surround_dict = {
	\ 'mb': '（\r）', 'm(': '（ \r ）', 'm)': '（\r）',
	\ 'mB': '｛\r｝', 'm{': '｛ \r ｝', 'm}': '｛\r｝',
	\ 'ma': '＜\r＞', 'm<': '＜ \r ＞', 'm>': '＜\r＞',
	\ 'mA': '［\r］', 'm[': '［ \r ］', 'm]': '［\r］',
	\ 'mk': '「\r」',
	\ 'mn': '『\r』',
	\ 'ms': '【\r】',
	\ 'U' : 'https://\r/',
	\ }
" NERDTree
let g:NERDTreeMapActivateNode = 'e'
let g:NERDTreeMapOpenSplit = 's'
let g:NERDTreeMapOpenVSplit = 'v'
" rainbow vim-gas vim-lion
let g:rainbow_active = 1
let g:gasCppComments = 1
let g:lion_squeeze_spaces = 1

filet plugin indent on
syn enable
aug vimrc
	au!
	au ColorScheme * hi Cursor guifg=fg guibg=Red
	au ColorScheme * hi CursorIM guifg=Black guibg=Blue
	au ColorScheme * hi TabLineFill guibg=#808080
	au ColorScheme * hi TrailingWhiteSpace ctermbg=darkred guibg=darkred
	au ColorScheme * hi IdeographicSpace term=underline ctermbg=DarkGreen guibg=DarkGreen
	au ColorScheme * call <SID>MultiHlSetup()
	au ColorScheme molokai hi Visual ctermfg=none
	au VimEnter * sil! call textobj#user#plugin('surround', {
		\ 'surround-mb': {'pattern': ['（', '）'], 'select-a': 'amb', 'select-i': 'imb'},
		\ 'surround-mB': {'pattern': ['｛', '｝'], 'select-a': 'amB', 'select-i': 'imB'},
		\ 'surround-ma': {'pattern': ['＜', '＞'], 'select-a': 'ama', 'select-i': 'ima'},
		\ 'surround-mA': {'pattern': ['［', '］'], 'select-a': 'amA', 'select-i': 'imA'},
		\ 'surround-mk': {'pattern': ['「', '」'], 'select-a': 'amk', 'select-i': 'imk'},
		\ 'surround-mn': {'pattern': ['『', '』'], 'select-a': 'amn', 'select-i': 'imn'},
		\ 'surround-ms': {'pattern': ['【', '】'], 'select-a': 'ams', 'select-i': 'ims'},
		\ })
	au FileType c setl textwidth=80 cindent cinoptions=:0(s
	au FileType git setl vartabstop=9,8 | let b:show_trailing_ws = 0
	au FileType help nno <buffer> <CR> <C-]>
	au FileType html setl indentkeys=
	au FileType info nma <buffer> gu <Plug>(InfoUp)
	au FileType info nma <buffer> gn <Plug>(InfoNext)
	au FileType info nma <buffer> gp <Plug>(InfoPrev)
	au FileType info nma <buffer> gm <Plug>(InfoMenu)
	au FileType info nma <buffer> gf <Plug>(InfoFollow)
	au FileType info nma <buffer> go <Plug>(InfoGoto)
	au FileType java setl cindent cinoptions=(sJ1j1
	au FileType man nno <buffer> <silent> q :q<CR>
	au FileType markdown setl tabstop=8
	au FileType php setl matchpairs-=<:>
	au FileType ps1 setl expandtab shiftwidth=2
	au FileType rust setl softtabstop=0 textwidth=100
	au FileType rust nno <buffer> <Leader>t <Cmd>call <SID>Command({}, 1, 0, 0, ['cargo', 'test'])<CR>
	au FileType rust nno <buffer> <Leader>u <Cmd>call <SID>Command({}, 1, 0, 0, ['cargo', 'run'])<CR>
	au FileType scheme setl expandtab shiftwidth=2 lispwords+=syntax-case,with-syntax
	au FileType scheme ino <expr> <buffer> <C-F> empty(getline('.')) ? "<C-O>cc" : "<C-O>=="
	au FileType sh setl isfname-== | call autocmd_add([#{bufnr: bufnr(), cmd: 'setl indentkeys-=)', event: 'BufEnter', once: v:true}])
	au BufNewFile *.go,*.pl,*.py,*.sh call <SID>Template()
	au BufNewFile,BufRead * if &ft ==# 'asm' | se ft=gas | endif
	au BufNewFile,BufRead * if &ft ==# 'diff' | se ft=git textwidth=0 | endif
	au BufNewFile,BufRead */git/config,*.gitconfig se ft=gitconfig
	au BufNewFile,BufRead */yapf/style se ft=cfg
	au BufNewFile,BufRead dircolors se ft=dircolors
	au BufReadPost * call <SID>GoToLastLine()
	au StdinReadPost * se nomodified
	au BufWinEnter,InsertLeave * call <SID>HlTrailingWs(0, 0)
	au InsertEnter * call <SID>HlTrailingWs(0, 1)
	au BufWinEnter * call <SID>HlIdeoSpace(0)
	au BufWinEnter * call <SID>SetTagfunc()
	au BufWinEnter */linux/* ALEDisableAllBuffer
	au CmdwinEnter * nno <buffer> g<CR> <Cmd>let g:CmdwinLastLine = line('.')<CR><CR>q:<Cmd>exe g:CmdwinLastLine<CR>
	au TextYankPost * call <SID>CopyUnnamed()
aug END
sil! colo molokai
if filereadable(expand('~/.localvimrc.vim'))
	so ~/.localvimrc.vim
endif
