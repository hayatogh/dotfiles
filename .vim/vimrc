set encoding=utf-8
scriptencoding utf-8

set autoread
set backspace=indent
set belloff=backspace,cursor,error,showmatch,esc visualbell
set showbreak=>\  breakindent breakindentopt=shift:14,min:22
set ignorecase smartcase
set casemap=keepascii
set clipboard=unnamed,unnamedplus
set colorcolumn=+1
set completeopt=menu,menuone,preview
set confirm
set cursorline
set diffopt=filler,vertical,closeoff
set display=lastline
set fileencodings=ucs-bom,utf-8,default,euc-jp,cp932
set fileformats=unix,dos
set fillchars=vert:│,fold:-
set guioptions=!Mr
set formatoptions+=mMj
set guicursor=a:blinkon0
set helplang=Ja,En
set history=1000
set smartindent autoindent
set lispwords-=if
set list listchars=tab:»-,extends:»,precedes:«,nbsp:◦
set showmatch matchtime=1 matchpairs+=「:」,（:）,『:』,【:】,［:］
set modeline modelines=3
set mouse=a mousemodel=extend nomousehide
let s:in_screen = &term =~# 'screen'
if s:in_screen
	set mouse=
endif
set number relativenumber
set pastetoggle=<F10>
set path+=include,./include,arch/x86/include,./arch/x86/include
if has('linux')
	let s:moddir = '/lib/modules/' . substitute(system('uname -r'), '\n', '', '') . '/source'
	let &path .= ',' . s:moddir . '/include,' . s:moddir . '/arch/x86/include'
	unlet s:moddir
endif
set pumheight=10
set report=15
set scrolloff=3 sidescroll=1 sidescrolloff=10
set incsearch hlsearch nowrapscan
set shortmess=aoOtT
set splitbelow splitright
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc,.exe,.lock
set suffixesadd=.tex
set laststatus=2
let g:CRLF = {'unix': 'LF', 'dos': 'CRLF', 'mac': 'CR'}
set statusline=[%f]%<%h%m%r[%{&fileencoding}%{&bomb?'(bomb)':''}][%{g:CRLF[&fileformat]}][%Y][0x%02.4B]%{&paste?'<paste>':''}%=%l,%c%V\ %P\ %LL%{wordcount().chars-line('$')}C%{g:Imzero()}
set showtabline=2
function! s:Tablabel(tabpagenr)
	let l:buflist = tabpagebuflist(a:tabpagenr)
	let l:curbufnr = l:buflist[tabpagewinnr(a:tabpagenr) - 1]
	let l:hi = a:tabpagenr == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
	let l:no = len(l:buflist) == 1 ? '' : len(l:buflist)
	let l:mod = len(filter(copy(l:buflist), 'getbufvar(v:val, "&modified")')) ? '+' : ''
	let l:sp = (l:no . l:mod) == '' ? '' : ' '
	let l:fname = fnamemodify(bufname(l:curbufnr), ':t')
	let l:fname = l:fname == '' ? '_' : l:fname
	return '%' . a:tabpagenr . 'T%#Title#' . l:no . l:hi . l:mod . l:sp . l:fname . '%#TabLineFill#'
endfunction
function! g:Cuitabline()
	let l:tablabels = join(map(range(1, tabpagenr('$')), '<SID>Tablabel(v:val)'), ' ')
	let l:info = strftime('%m/%d%a %H:%M') . ' %#TabLine#' . fnamemodify(getcwd(), ':~') . ' '
	return l:tablabels . ' %T%=' . l:info
endfunction
set tabline=%!g:Cuitabline()
set noexpandtab shiftwidth=0 tabstop=8
set tags=./tags;./../../,tags;../../
set ttimeoutlen=1
let $MYVIM = fnamemodify($MYVIMRC, ':p:h')
set viminfofile=$MYVIM/.viminfo directory=$MYVIM/swap
set virtualedit=block
set wildmenu wildignorecase wildmode=list:longest,full
set wrap
let g:c_comment_strings = 1
let g:vim_json_conceal = 0
let g:mapleader = ' '
let g:maplocalleader = ' '
let g:readline_has_bash = 1
let g:rust_bang_comment_leader = 1
let g:tex_conceal = ''
let g:tex_flavor = 'latex'
let g:vim_indent_cont = &tabstop
filetype plugin indent on
syntax enable

if &term == 'xterm' || has('win32')
	set t_Co=256
endif
if !has('win32')
	let &t_VS .= "\e]12;#ff00ff\x7"
	let &t_EI .= "\e]12;#ff00ff\x7"
endif

function! g:Imzero()
	return ''
endfunction
let s:has_clipexe = 0
if has('gui_win32')
	function! g:Imzero()
		if s:autoIminsertZero
			set iminsert=0
		endif
		return ''
	endfunction
elseif $WSL_DISTRO_NAME != '' || $MSYSTEM != ''
	if s:in_screen
		call echoraw("\e[<0t\e[<s")
		let &t_SI .= "\e[<r"
		let &t_EI .= "\e[<s\e[<0t"
		let &t_te .= "\e[<0t\e[<s"
		function! g:Imzero()
			if s:autoIminsertZero
				call echoraw("\e[<0t\e[<s")
			endif
			return ''
		endfunction
	else
		call echoraw("\eP\e[<0t\e[<s\e\\")
		let &t_SI .= "\eP\e[<r\e\\"
		let &t_EI .= "\eP\e[<s\e[<0t\e\\"
		let &t_te .= "\eP\e[<0t\e[<s\e\\"
		let &t_BE = "\eP\e[?2004h\e\\"
		let &t_BD = "\eP\e[?2004l\e\\"
		let &t_PS = "\e[200~"
		let &t_PE = "\e[201~"
		function! g:Imzero()
			if s:autoIminsertZero
				call echoraw("\eP\e[<0t\e[<s\e\\")
			endif
			return ''
		endfunction
	endif
	let s:has_clipexe = executable('clip.exe')
endif
let s:pythonexe = executable('python3') ? 'python3' : 'python'

" mapping
map Y y$

nnoremap <silent> mm :<C-U>nohlsearch<CR>
nnoremap <silent> mn :<C-U>Hi0<CR>

nnoremap <silent> <C-W><C-E> :tabedit<CR>
nnoremap <silent> <C-W><C-L> :tabnext<CR>
nnoremap <silent> <C-W><C-H> :tabprevious<CR>
nnoremap <silent> <C-W><C-O> :tabonly<CR>
tnoremap <silent> <C-W><C-E> <C-W>:tabedit<CR>
tnoremap <silent> <C-W><C-L> <C-W>:tabnext<CR>
tnoremap <silent> <C-W><C-H> <C-W>:tabprevious<CR>
tnoremap <silent> <C-W><C-O> <C-W>:tabonly<CR>

nnoremap <silent> <Plug>Blankline :call append(line('.'), '')<CR>j:call repeat#set("\<Plug>Blankline")<CR>
nmap <Leader>o <Plug>Blankline

nnoremap Q gq
nnoremap <Leader>w :w<CR>
nnoremap <Leader>n :n<CR>
nnoremap <Leader>p :N<CR>
nnoremap <Leader>c :clo<CR>

function! s:ResetSearchDirection(cmd)
	let @/=@/
	nunmap n
	nunmap N
	return a:cmd
endfunction
function! s:ConsistentSearch(cmd)
	nnoremap <expr> n <SID>ResetSearchDirection('n')
	nnoremap <expr> N <SID>ResetSearchDirection('N')
	return a:cmd
endfunction
nnoremap <expr> ? <SID>ConsistentSearch('?')
nnoremap <expr> # <SID>ConsistentSearch('#')
nnoremap <expr> g# <SID>ConsistentSearch('g#')
function! s:Search(zero, word)
	if a:zero == 0
		let l:pat = '\<' . a:word . '\>'
	else
		let l:pat = a:word
	endif
	call histadd('/', l:pat)
	let @/=l:pat
	call <SID>CopyToScreenReg(a:word)
endfunction
nnoremap <silent> <Plug>Star0 :call <SID>Search(0, expand('<cword>'))<CR>"_yiw<BS>
nnoremap <silent> <Plug>Star1 :call <SID>Search(1, expand('<cword>'))<CR>"_yiw<BS>
nmap *  <Plug>Star0n
nmap g* <Plug>Star1n
nnoremap g/ /\<\><Left><Left>

if has('win32')
	silent! vunmap <C-X>
endif

inoremap <C-U> <C-G>u<C-U>

function! g:RestoreRegister()
	silent! let @* = s:restore_reg
	silent! let @+ = s:restore_reg
	let @" = s:restore_reg
	return ''
endfunction
function! s:Repl()
	silent! let s:restore_reg = @*
	silent! let s:restore_reg = @+
	let s:restore_reg = @"
	return "p@=g:RestoreRegister()\<CR>"
endfunction
vnoremap <expr> p <SID>Repl()

function! s:Getfname()
	let l:fname = fnamemodify(bufname(), ':t') . ':' . getcurpos()[1]
	silent! let @* = l:fname
	silent! let @+ = l:fname
	call <SID>CopyToScreenReg(l:fname)
	return l:fname
endfunction
command! Getfname echo <SID>Getfname()
nnoremap <silent> yd :<C-U>echo <SID>Getfname()<CR>

cnoremap <Left> <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>
cnoremap <Up> <C-P>
cnoremap <Down> <C-N>
cnoremap <C-A> <Home>
" cnoremap <C-O>
" cnoremap <C-B>
function s:RegexRubout(re)
	let l:right = strpart(getcmdline(), getcmdpos() - 1)
	let l:left = strpart(getcmdline(), 0, getcmdpos() - 1)
	let l:left = substitute(l:left, a:re, '', '')
	call setcmdpos(strlen(l:left) + 1)
	return l:left . l:right
endfunction
cnoremap <Esc>/ <C-\>e<SID>RegexRubout('\v[^/ ]*/? *$')<CR>
cnoremap <C-W>  <C-\>e<SID>RegexRubout('\v([a-zA-z]+\|[0-9]+\|.) *$')<CR>
cnoremap <Esc>w <C-\>e<SID>RegexRubout('\v[^ ]* *$')<CR>

nmap ysa' ys2i'
nmap ysa" ys2i"
nmap ysa` ys2i`

nmap <Leader>0 :<C-U>Hi0<CR>
nmap <Leader>1 :<C-U>Hi1 <C-R><C-W><CR>
nmap <Leader>2 :<C-U>Hi2 <C-R><C-W><CR>
nmap <Leader>3 :<C-U>Hi3 <C-R><C-W><CR>
nmap <Leader>4 :<C-U>Hi4 <C-R><C-W><CR>
nmap <Leader>5 :<C-U>Hi5 <C-R><C-W><CR>
nmap <Leader>6 :<C-U>Hi6 <C-R><C-W><CR>

function! s:BackRun(cmd)
	let l:n = bufnr('!' . a:cmd)
	if l:n != -1
		execute 'bdelete ' . l:n
	endif
	call term_start(a:cmd)
	wincmd p
endfunction
nnoremap <Leader>t :call <SID>BackRun('cargo test')<CR>
nnoremap <Leader>u :call <SID>BackRun('cargo run')<CR>

nnoremap <Esc>m <C-W>-
nnoremap <Esc>p <C-W>+

cnoremap <C-G> <C-\><C-N>
inoremap <C-G> <C-\><C-N>

" excommand
command! DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis

function! s:ReadTypescript()
	let l:ts = map(readfile('typescript')[1:-3], {_, val -> substitute(val, '\s\+$', '', '')})
	if &ft == 'c'
		let l:ts = ['/*'] + l:ts + ['*/']
	endif
	call append(getpos('.')[1], l:ts)
endfunction
command! Typesc call <SID>ReadTypescript()

command! Hitest runtime syntax/hitest.vim
command! Colortest runtime syntax/colortest.vim

command! -nargs=0 Cdhere cd %:p:h

function! s:FixWhitespace(line1,line2)
	let l:save_cursor = getcurpos()
	silent! execute a:line1 . ',' . a:line2 . 's/\\\@<!\s\+$//'
	call setpos('.', l:save_cursor)
endfunction
command! -range=% FixWhitespace call <SID>FixWhitespace(<line1>, <line2>)

function! s:XXD(do)
	if a:do
		let b:save_ft_binary = [&filetype, &l:binary]
		let &binary = 1
		silent edit " for binary to take effect
		let &ft = 'xxd'
		%!xxd
	else
		if exists('b:save_ft_binary')
			let [&filetype, &l:binary] = b:save_ft_binary
			unlet b:save_ft_binary
		endif
		%!xxd -r
	endif
endfunction
command! XXD call <SID>XXD(1)
command! XXDundo call <SID>XXD(0)

function! s:MultiHlSetup()
	highlight Multihl1 ctermbg=14 ctermfg=8 guibg=#00ffff guifg=#808080
	highlight Multihl2 ctermbg=13 ctermfg=8 guibg=#ff00ff guifg=#808080
	highlight Multihl3 ctermbg=11 ctermfg=8 guibg=#ffff00 guifg=#808080
	highlight Multihl4 ctermbg=1  ctermfg=7 guibg=#800000 guifg=#c0c0c0
	highlight Multihl5 ctermbg=4  ctermfg=7 guibg=#000080 guifg=#c0c0c0
	highlight Multihl6 ctermbg=2  ctermfg=7 guibg=#008000 guifg=#c0c0c0
endfunction
function! s:Hi(num, ...)
	if a:num == 0
		call clearmatches()
	else
		silent! call matchdelete(a:num + 5)
		if a:0 != 0
			call matchadd('Multihl' . a:num, a:1, 10, a:num + 5)
			call histadd(':', 'Hi' . a:num . ' ' . a:1)
			return
		endif
	endif
	call histadd(':', 'Hi' . a:num)
endfunction
command! -nargs=0 Hi0 call <SID>Hi(0)
command! -nargs=? Hi1 call <SID>Hi(1, <f-args>)
command! -nargs=? Hi2 call <SID>Hi(2, <f-args>)
command! -nargs=? Hi3 call <SID>Hi(3, <f-args>)
command! -nargs=? Hi4 call <SID>Hi(4, <f-args>)
command! -nargs=? Hi5 call <SID>Hi(5, <f-args>)
command! -nargs=? Hi6 call <SID>Hi(6, <f-args>)

command! -nargs=+ MYMANPAGER execute "Man " . <q-args> | only

function! s:Align(cmd, line1, line2, ...)
	let l:save_cursor = getcurpos()
	if a:0 == 0
		let l:char = input('')
	else
		let l:char = a:1
	endif
	execute 'normal ' . a:line1 . 'GV' . a:line2 . 'G' . a:cmd . l:char
	call setpos('.', l:save_cursor)
endfunction
command! -range -nargs=? AlignRight call <SID>Align('gL', <line1>, <line2>, <f-args>)
command! -range -nargs=? AlignLeft  call <SID>Align('gl', <line1>, <line2>, <f-args>)

command! -nargs=0 Reload let s:undoreload = &undoreload | set undoreload=0 | edit | let &undoreload = s:undoreload

function! s:Nkf()
	let l:fname = fnamemodify(expand('%'), ':p')
	if executable('uchardet')
		let l:enc = system('uchardet ' . l:fname)
	elseif executable('nkf')
		let l:enc = system('nkf --guess=1 ' . l:fname)
	else
		echoerr 'uchardet or nkf must be installed!'
		return
	endif
	execute 'e ++enc=' . l:enc
endfunction
command! -nargs=0 Nkf call <SID>Nkf()

let s:shiflag = has('win32') ? &shellcmdflag : '-ic'
function! s:Command(is_i, ...)
	let l:cmd = &shell . ' ' . s:shiflag . ' "' . join(a:000) . '"'
	let l:opt = a:is_i ? {'term_finish': 'close'} : {'hidden': 1, 'term_finish': 'open', 'term_opencmd': 'botright sbuf %d | setl modifiable | $'}
	call term_start(l:cmd, l:opt)
endfunction
function! s:BashComp(ArgLead, CmdLine, CursorPos)
	return g:bash#complete(substitute(strpart(a:CmdLine, 0, a:CursorPos), '^\a\+ ', '', ''))
endfunction
if has('win32')
	command! -nargs=* -complete=file S call <SID>Command(0, <f-args>)
else
	command! -nargs=* -complete=customlist,<SID>BashComp S call <SID>Command(0, <f-args>)
	command! -nargs=* -complete=customlist,<SID>BashComp I call <SID>Command(1, <f-args>)
endif

let s:template = {
	\ 'c'     : ['#include <stdio.h>', '', 'int main(void) {', '	printf("Hello\n");', '	return 0;', '}'],
	\ 'go'    : ['package main', '', 'import "fmt"', '', 'func main() {', '	fmt.Println("Hello")', '}'],
	\ 'perl'  : ['#!/usr/bin/env perl', 'use strict;', 'use warnings;'],
	\ 'python': '#!/usr/bin/env ' . s:pythonexe,
	\ 'sh'    : ['#!/usr/bin/env bash', 'set -euxo pipefail'],
	\ }
let s:template_after = {
	\ 'c' : 'call cursor(4, 2)',
	\ 'go': 'call cursor(6, 2)',
	\ '_':  'call cursor(line(''$''), 1)',
	\ }
function! s:Template()
	if has_key(s:template, &filetype)
		call append(0, s:template[&filetype])
		if getline('$') == ''
			$delete _
		endif
		if has_key(s:template_after, &filetype)
			execute(s:template_after[&filetype])
		else
			execute(s:template_after['_'])
		endif
		echon ' Template loaded'
	endif
endfunction
command! -nargs=0 Template call <SID>Template()

function! s:Sort(pat)
	let l:save_reg = @a
	normal! gv"ay
	let @a = join(sort(split(eval('@a'), a:pat)), a:pat)
	normal! gv"ap
	let @a = l:save_reg
endfunction
command! -range Sort call <SID>Sort(' ')
command! -range SortComma call <SID>Sort(', ')
command! -nargs=1 -range SortSep call <SID>Sort(<f-args>)

" autocommand
command! AUTOiminsertzero let s:autoIminsertZero = !s:autoIminsertZero
let s:autoIminsertZero=0

command! AUTOhltrailingwhitespaces call <SID>ToggleAutoHlTrailingWhiteSpaces()
let s:autoHlTrailingWhiteSpaces = 1
function! s:ToggleAutoHlTrailingWhiteSpaces()
	let s:autoHlTrailingWhiteSpaces = !s:autoHlTrailingWhiteSpaces
	call <SID>HlTrailingWhiteSpace(1)
endfunction
function! s:HlTrailingWhiteSpace(isNormal)
	silent! call matchdelete(4)
	if !s:autoHlTrailingWhiteSpaces | return | endif
	if a:isNormal
		call matchadd('TrailingWhiteSpace', '\\\@<!\s\+$', 10, 4)
	else
		call matchadd('TrailingWhiteSpace', '\\\@<!\s\+\%#\@<!$', 10, 4)
	endif
endfunction

command! AUTOhlideographicspace call <SID>ToggleAutoHlIdeographicSpace()
let s:autoHlIdeographicSpace = 1
function! s:ToggleAutoHlIdeographicSpace()
	let s:autoHlIdeographicSpace = !s:autoHlIdeographicSpace
	call <SID>HlIdeographicSpace()
endfunction
function! s:HlIdeographicSpace()
	silent! call matchdelete(5)
	if !s:autoHlIdeographicSpace | return | endif
	call matchadd('IdeographicSpace', '[\u3000]', 10, 5)
endfunction

command! AUTOhalfcommas let s:autoHalfCommas = !s:autoHalfCommas
let s:autoHalfCommas = 0
function! s:HalfCommas()
	if !s:autoHalfCommas | return | endif
	let l:curpos = getcurpos()
	silent! keeppatterns %s/，\+$/\=repeat(',', strchars(submatch(0)))/g
	silent! keeppatterns %s/．\+$/\=repeat('.', strchars(submatch(0)))/g
	silent! keeppatterns %s/，\+\ze /\=repeat(',', strchars(submatch(0)))/g
	silent! keeppatterns %s/．\+\ze /\=repeat('.', strchars(submatch(0)))/g
	silent! keeppatterns %s/，\+/\=repeat(',', strchars(submatch(0))) . ' '/g
	silent! keeppatterns %s/．\+/\=repeat('.', strchars(submatch(0))) . ' '/g
	call setpos('.', l:curpos)
endfunction

command! AUTOconvertpunctuation let s:autoConvertPunctuation = !s:autoConvertPunctuation
let s:autoConvertPunctuation = 0
function! s:ConvertPunctuation()
	if !s:autoConvertPunctuation | return | endif
	let l:curpos = getcurpos()
	silent! keeppatterns %s/．/。/g
	silent! keeppatterns %s/，/、/g
	silent! keeppatterns %s/\.\.\./…/g
	" ―
	call setpos('.', l:curpos)
endfunction

function! s:CopyToScreenRegUnnamed()
	if v:event.regname == ''
		call <SID>CopyToScreenReg(join(v:event.regcontents, "\n"))
	endif
endfunction
function! s:CopyToScreenReg(str)
	if s:in_screen
		let l:escaped = escape(a:str, '\$^')
		if len(l:escaped) <= 749
			call job_start(['screen', '-X', 'register', '.', l:escaped])
		endif
	endif
	if s:has_clipexe
		let l:escaped = shellescape(escape(a:str, '\'))
		call job_start(['/bin/sh', '-c', 'echo -n ' . l:escaped . ' | clip.exe'])
	endif
endfunction

function! s:SetScreenTitle()
	if s:in_screen
		call job_start(['screen', '-X', 'title', 'vim'])
	endif
endfunction

augroup vimrc
	autocmd!
	autocmd BufRead,BufNewFile * if &ft == 'asm' | set ft=gas | endif
	autocmd BufRead,BufNewFile *.lalrpop set ft=rust
	autocmd BufReadPost * if line('''"') >= 1 && line('''"') <= line('$') && &ft !~# 'commit' | execute 'normal! g`"' | endif
	autocmd StdinReadPost * set nomodified
	autocmd CmdwinEnter * nnoremap <buffer> <F5> :let g:CmdwinLastLineNum=line('.')<CR><CR>q::execute g:CmdwinLastLineNum<CR>
	autocmd Colorscheme * highlight Cursor guifg=Black guibg=Cyan
	autocmd Colorscheme * highlight CursorIM guifg=Black guibg=Magenta
	autocmd Colorscheme * highlight TabLineFill guibg=#808080
	autocmd ColorScheme * highlight TrailingWhiteSpace ctermbg=darkred guibg=darkred
	autocmd Colorscheme * highlight IdeographicSpace term=underline ctermbg=DarkGreen guibg=DarkGreen

	autocmd BufEnter,BufRead,BufNew * call <SID>HlTrailingWhiteSpace(1)
	autocmd InsertLeave * call <SID>HlTrailingWhiteSpace(1)
	autocmd InsertEnter * call <SID>HlTrailingWhiteSpace(0)
	autocmd BufEnter,BufRead,BufNew * call <SID>HlIdeographicSpace()
	autocmd Colorscheme * call <SID>MultiHlSetup()
	autocmd BufNewFile *.go,*.pl,*.py,*.sh call <SID>Template()
	autocmd BufWritePre *.tex call <SID>HalfCommas()
	autocmd BufWritePre *.txt call <SID>ConvertPunctuation()
	autocmd TextYankPost * call <SID>CopyToScreenRegUnnamed()
	autocmd VimResume * call <SID>SetScreenTitle()
augroup END

" pack
function! s:Minpac()
	if !exists('*minpac#init')
		call system('git clone --depth 1 -- git://github.com/matsuhav/minpac.git ~/.vim/pack/minpac/opt/minpac')
		packadd minpac
	endif
	call minpac#init({'jobs': 4, 'autoyes': 1})
	call minpac#add('matsuhav/minpac', {'type': 'opt'})

	call minpac#add('tpope/vim-commentary')
	call minpac#add('vim-jp/vimdoc-ja')
	call minpac#add('editorconfig/editorconfig-vim', {'submodule': 0})
	call minpac#add('mattn/emmet-vim', {'submodule': 0})
	call minpac#add('tpope/vim-eunuch')
	call minpac#add('cohama/lexima.vim')
	call minpac#add('tommcdo/vim-lion')
	call minpac#add('scrooloose/nerdtree')
	call minpac#add('luochen1990/rainbow')
	call minpac#add('matsuhav/vim-surround')
	call minpac#add('kana/vim-tabpagecd')
	call minpac#add('guns/xterm-color-table.vim')
	" external commands
	call minpac#add('dense-analysis/ale')
	call minpac#add('junegunn/fzf.vim')
	call minpac#add('HiPhish/info.vim')
	call minpac#add('thinca/vim-quickrun')
	" libraries
	call minpac#add('kana/vim-operator-user')
	call minpac#add('kana/vim-textobj-indent')
	call minpac#add('kana/vim-textobj-user')
	call minpac#add('matsuhav/vim-bash-completion')
	call minpac#add('tpope/vim-repeat')
	" colorscheme
	call minpac#add('tomasr/molokai')
	" syntax and filetype plugins
	call minpac#add('kchmck/vim-coffee-script')
	call minpac#add('chrisbra/csv.vim')
	call minpac#add('Shirk/vim-gas')
	call minpac#add('tpope/vim-markdown')
	call minpac#add('previm/previm')
	call minpac#add('vim-python/python-syntax')
	call minpac#add('wlangstroth/vim-racket')
	call minpac#add('lervag/vimtex')
	call minpac#add('cespare/vim-toml')
	call minpac#clean()
	call minpac#update()
endfunction
command! MinLoad silent! source $MYVIMRC | call <SID>Minpac()
" previm
let g:previm_enable_realtime = 1
if has('win32')
	let g:previm_open_cmd = '"C:\Program Files\Firefox Developer Edition\firefox.exe"'
elseif has('win32unix')
	let g:previm_open_cmd = '"/c/Program Files/Firefox Developer Edition/firefox.exe"'
elseif has('mac')
	let g:previm_open_cmd = 'open -a Firefox'
else
	let g:previm_open_cmd = 'firefox'
endif
let g:loaded_previm = 1
command! -nargs=0 PrevimOpen unlet g:loaded_previm | runtime plugin/previm.vim | doautocmd Previm FileType | PrevimOpen
" vimtex
if has('win32')
	let g:vimtex_view_general_viewer = 'SumatraPDF'
	let g:vimtex_view_general_options_latexmk = '-reuse-instance'
	let g:vimtex_view_general_options = '-reuse-instance -forward-search @tex @line @pdf'
endif
" lexima
let g:lexima_no_default_rules = 1
let g:lexima_map_escape=''
" quickrun
nmap <Leader>r <Plug>(quickrun)
let g:quickrun_config = {
	\ 'python': {
	\   'command': s:pythonexe
	\ },
	\ 'rust': {
	\   'command': 'runner',
	\   'exec': '%c %s %o',
	\ },
	\ 'scheme': {
	\   'command': 'chezscheme',
	\   'exec': '%c --script %s',
	\ },
	\ '_': {
	\   'outputter/buffer/opener': 'botright new',
	\   'outputter/buffer/close_on_empty': 1,
	\   'runner': 'job',
	\ },
	\ }
if has('win32')
	let g:quickrun_config.scheme = {
		\ 'command': 'C:\Program Files\Racket\mzscheme.exe',
		\ 'exec': '%c %o -e ''(load "%s")'' %a',
		\ }
elseif has('osxdarwin')
	let g:quickrun_config.scheme.command = 'chez'
endif
" ale
nmap <Leader>j <Plug>(ale_next)
nmap <Leader>k <Plug>(ale_previous)
nmap <Leader>h <Plug>(ale_detail)

function! s:ALEFixOnSaveToggle(vartype, value)
	let l:new = a:value == -1 ? '!' . get(eval(a:vartype . ':'), 'ale_fix_on_save', 0) : a:value
	execute 'let ' . a:vartype . ':ale_fix_on_save = ' . l:new
endfunction
command! -bar ALEFixOnSaveToggle        call <SID>ALEFixOnSaveToggle('g', -1)
command! -bar ALEFixOnSaveToggleBuffer  call <SID>ALEFixOnSaveToggle('b', -1)
command! -bar ALEFixOnSaveEnable        call <SID>ALEFixOnSaveToggle('g', 1)
command! -bar ALEFixOnSaveEnableBuffer  call <SID>ALEFixOnSaveToggle('b', 1)
command! -bar ALEFixOnSaveDisable       call <SID>ALEFixOnSaveToggle('g', 0)
command! -bar ALEFixOnSaveDisableBuffer call <SID>ALEFixOnSaveToggle('b', 0)
command! -bar ALEEnableAll        ALEEnable | ALEFixOnSaveEnable
command! -bar ALEEnableAllBuffer  ALEEnableBuffer | ALEFixOnSaveEnableBuffer
command! -bar ALEDisableAll       ALEDisable | ALEFixOnSaveDisable
command! -bar ALEDisableAllBuffer ALEDisableBuffer | ALEFixOnSaveDisableBuffer

function! s:Tjump(sp)
	if tagfiles() == []
		return ":ALEGoToDefinition" . (a:sp ? ' -split' : '') . "\<CR>"
	else
		return (a:sp ? "\<C-W>" : '') . "g\<C-]>"
	endif
endfunction
nnoremap <expr> <C-]>      <SID>Tjump(0)
vnoremap <expr> <C-]>      <SID>Tjump(0)
nnoremap <expr> <C-W><C-]> <SID>Tjump(1)
vnoremap <expr> <C-W><C-]> <SID>Tjump(1)

let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
let g:ale_linters = {
	\ 'tex'   : ['chktex'],
	\ 'c'     : [],
	\ 'cpp'   : [],
	\ 'ocaml' : ['ocamllsp'],
	\ 'python': ['pylsp'],
	\ 'go'    : ['govet', 'gopls'],
	\ 'rust'  : ['rls', 'cargo'],
	\ }
let g:ale_fixers = {
	\ 'ocaml' : ['ocamlformat'],
	\ 'python': ['isort', 'yapf'],
	\ 'go'    : ['gofmt', 'goimports'],
	\ 'rust'  : ['rustfmt'],
	\ }
let g:ale_rust_cargo_use_clippy = executable('cargo-clippy')
let g:ale_completion_enabled = 1
let g:ale_fix_on_save = 1
let g:ale_hover_cursor = 0
if has('win32unix')
	let g:ale_enabled = 0
endif
" vim-markdown
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', 'c', 'cpp']
let g:markdown_syntax_conceal = 0
" vim-surround
let g:surround_dict = {
	\ 'U' : 'https://\r/',
	\ 'mk': '「\r」',
	\ 'mn': '『\r』',
	\ 'mb': '（\r）',
	\ 'ms': '【\r】',
	\ 'ma': '［\r］',
	\ }
" fzf
if has('osxdarwin')
	silent! source /usr/local/opt/fzf/plugin/fzf.vim
else
	silent! source /usr/share/doc/fzf/examples/fzf.vim
endif
" rainbow vim-gas vim-lion emmet python-syntax
let g:rainbow_active = 1
let g:gasCppComments = 1
let g:lion_squeeze_spaces = 1
let g:user_emmet_leader_key='<C-K>'
let g:python_highlight_all = 1

packloadall!
packadd matchit
silent! packadd termdebug
silent! packadd minpac
runtime ftplugin/man.vim
silent! colorscheme molokai
" lexima
if exists('*lexima#add_rule')
	function! s:Lexima_endwise(at, end, filetype)
		return {'char': '<CR>', 'input': '<CR>', 'input_after': '<CR>' . a:end, 'at': a:at, 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . a:end, 'filetype': a:filetype}
	endfunction
	let s:rulelist = [
		"\ {'char': '(', 'input_after': ')'},
		"\ {'char': ')', 'at': '\%#)', 'leave': 1},
		"\ {'char': '<C-H>', 'at': '(\%#)', 'delete': 1},
		"\ {'char': '{', 'input_after': '}'},
		"\ {'char': '}', 'at': '\%#}', 'leave': 1},
		"\ {'char': '<C-H>', 'at': '{\%#}', 'delete': 1},
		"\ {'char': '[', 'input_after': ']'},
		"\ {'char': ']', 'at': '\%#]', 'leave': 1},
		"\ {'char': '<C-H>', 'at': '\[\%#\]', 'delete': 1},
		\ {'char': '<CR>', 'at': '(\%#)',   'input_after': '<CR>'},
		\ {'char': '<CR>', 'at': '{\%#}',   'input_after': '<CR>'},
		\ {'char': '<CR>', 'at': '\[\%#\]', 'input_after': '<CR>'},
		\ <SID>Lexima_endwise('^\s*if\>.*\%#$',         'endif',       'vim'),
		\ <SID>Lexima_endwise('^\s*while\>.*\%#$',      'endwhile',    'vim'),
		\ <SID>Lexima_endwise('^\s*for\>.*\%#$',        'endfor',      'vim'),
		\ <SID>Lexima_endwise('^\s*try\>.*\%#$',        'endtry',      'vim'),
		\ <SID>Lexima_endwise('^\s*function!.*\%#$',    'endfunction', 'vim'),
		\ <SID>Lexima_endwise('^\s*augroup\s\+.\+\%#$', 'augroup END', 'vim'),
		\ <SID>Lexima_endwise('^\s*\%(module\|def\|class\|if\|unless\|for\|while\|until\|case\)\>\%(.*[^.:@$]\<end\>\)\@!.*\%#$', 'end', 'ruby')
		\ <SID>Lexima_endwise('^\s*\%(begin\)\s*\%#$',                                                                            'end', 'ruby')
		\ <SID>Lexima_endwise('\%(^\s*#.*\)\@<!do\%(\s*|.*|\)\?\s*\%#$',                                                          'end', 'ruby')
		\ <SID>Lexima_endwise('\<\%(if\|unless\)\>.*\%#$',                                                                        'end', 'ruby')
		\ <SID>Lexima_endwise('\%(^\s*#.*\)\@<!do\s*\%#$', 'end', 'elixir'),
		\ <SID>Lexima_endwise('^\s*if\>.*\%#$',             'fi',   ['sh', 'zsh']),
		\ <SID>Lexima_endwise('^\s*case\>.*\%#$',           'esac', ['sh', 'zsh']),
		\ <SID>Lexima_endwise('\%(^\s*#.*\)\@<!do\>.*\%#$', 'done', ['sh', 'zsh']),
		\ <SID>Lexima_endwise('\%(^\s*#.*\)\@<!\<\%(module\|struct\|function\|if\|for\|while\|do\|let\|macro\)\>\%(.*\<end\>\)\@!.*\%#$', 'end', 'julia')
		\ <SID>Lexima_endwise('\%(^\s*#.*\)\@<!\s*\<\%(begin\|try\|quote\)\s*\%#$',                                                       'end', 'julia')
		\ {'char': '<CR>', 'input': '<CR>'},
		"\ inoremap <CR> <C-G>u<CR>
		\ ]
	delfunction s:Lexima_endwise
	for s:rule in s:rulelist
		call lexima#add_rule(s:rule)
	endfor
	unlet s:rule s:rulelist
endif
" vim-surround
if exists('*textobj#user#plugin')
	let s:surround_textobj = {
		\ 'surround-mk': {'pattern': ['「', '」'], 'select-a': 'amk', 'select-i': 'imk'},
		\ 'surround-mn': {'pattern': ['『', '』'], 'select-a': 'amn', 'select-i': 'imn'},
		\ 'surround-mb': {'pattern': ['（', '）'], 'select-a': 'amb', 'select-i': 'imb'},
		\ 'surround-ms': {'pattern': ['【', '】'], 'select-a': 'ams', 'select-i': 'ims'},
		\ 'surround-ma': {'pattern': ['［', '］'], 'select-a': 'ama', 'select-i': 'ima'},
		\ }
	call textobj#user#plugin('surround', s:surround_textobj)
	unlet s:surround_textobj
endif

" gui
if has("gui_running") && has('win32')
	set guifont=Consolas:h11
	set lines=30 columns=86
	let s:gvim_winpos_file = expand('~/.gvimwinpos')
	function! s:Save_gvim_win_pos()
		let l:pos = [getwinposx(), getwinposy()]
		call writefile(l:pos, s:gvim_winpos_file)
	endfunction
	augroup vimrc
		autocmd VimLeavePre * call <SID>Save_gvim_win_pos()
	augroup END
	if filereadable(s:gvim_winpos_file)
		let s:pos = readfile(s:gvim_winpos_file)
		let s:n = str2nr(strpart(v:servername, 4))
		execute 'winpos ' . (s:pos[0] + 32 * s:n) . ' ' . (s:pos[1] + 32 * s:n)
		unlet s:pos s:n
	endif

	nnoremap <silent> <M-Space> :simalt ~<CR>
	cnoremap <M-/> <C-\>e<SID>RegexRubout('\v[^/\\]*(/\|\\)? *$')<CR>
	cnoremap <M-w> <C-\>e<SID>RegexRubout('\v[^ ]* *$')<CR>
	nnoremap <M-m> <C-W>-
	nnoremap <M-p> <C-W>+
endif

if filereadable(expand('~/.localvimrc.vim'))
	source ~/.localvimrc.vim
endif
