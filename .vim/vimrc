set encoding=utf-8
scriptencoding utf-8
if !exists('$MYVIMRC')
	set nocompatible
	let $MYVIMRC = expand('<script>')
	let $MYVIM = fnamemodify($MYVIMRC, ':h')
	let &runtimepath = $MYVIM .. ',' .. &runtimepath .. ',' .. $MYVIM .. '/after'
	let &packpath = $MYVIM .. ',' .. &packpath .. ',' .. $MYVIM .. '/after'
endif

set autoread
set background=dark
set backspace=indent
set belloff=backspace,cursor,error,showmatch,esc visualbell
set showbreak= breakindent breakindentopt=shift:2 cpoptions+=n
set ignorecase smartcase
set casemap=keepascii
set clipboard=unnamed,unnamedplus
set colorcolumn=+1
set completeopt=menu,menuone,preview
set cursorline
set diffopt=filler,vertical,closeoff
set display=lastline
set fileencodings=ucs-bom,utf-8,default,euc-jp,cp932
set fileformats=unix,dos
set fillchars=vert:│,fold:-
set guioptions=!Mr
set formatoptions+=mMj
set guicursor=a:blinkon0
set helplang=Ja,En
set history=1000
set smartindent autoindent
set keywordprg=:Man
set lispwords-=if
set list listchars=tab:»-,extends:»,precedes:«,nbsp:◦
set showmatch matchtime=1 matchpairs+=「:」,（:）,『:』,【:】,［:］
set modeline modelines=3
set mouse=a mousemodel=extend nomousehide
let s:in_screen = &term =~# 'screen'
if s:in_screen
	set mouse=
endif
set number relativenumber
set pastetoggle=<F10>
set path+=include,./include,arch/x86/include,./arch/x86/include
if has('linux')
	let s:moddir = '/lib/modules/' . substitute(system('uname -r'), '\n', '', '') . '/source'
	let &path .= ',' . s:moddir . '/include,' . s:moddir . '/arch/x86/include'
	unlet s:moddir
endif
set pumheight=10
set report=15
set scrolloff=3 sidescroll=1 sidescrolloff=10
set incsearch hlsearch nowrapscan
if has('win32') && !has('gui_win32')
	set shell=pwsh
endif
set shortmess=aoOtT
set splitbelow splitright
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc,.exe,.lock
set suffixesadd=.tex
set laststatus=2
let g:CRLF = {'unix': 'LF', 'dos': 'CRLF', 'mac': 'CR'}
set statusline=[%f]%<%h%m%r[%{&fileencoding}%{&bomb?'(bomb)':''}][%{g:CRLF[&fileformat]}][%Y][0x%02.4B]%{&paste?'<paste>':''}%=%l,%c%V\ %P\ %LL%{wordcount().chars-line('$')}C%{g:Imzero()}
set showtabline=2
function! s:Tablabel(tabpagenr)
	let l:buflist = tabpagebuflist(a:tabpagenr)
	let l:curbufnr = l:buflist[tabpagewinnr(a:tabpagenr) - 1]
	let l:hi = a:tabpagenr == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
	let l:no = len(l:buflist) == 1 ? '' : len(l:buflist)
	let l:mod = len(filter(copy(l:buflist), 'getbufvar(v:val, "&modified")')) ? '+' : ''
	let l:sp = (l:no . l:mod) == '' ? '' : ' '
	let l:fname = fnamemodify(bufname(l:curbufnr), ':t')
	let l:fname = l:fname == '' ? '_' : l:fname
	return '%' . a:tabpagenr . 'T%#Title#' . l:no . l:hi . l:mod . l:sp . l:fname . '%#TabLineFill#'
endfunction
function! g:Cuitabline()
	let l:tablabels = join(map(range(1, tabpagenr('$')), '<SID>Tablabel(v:val)'), ' ')
	let l:info = strftime('%m/%d%a %H:%M') . ' %#TabLine#' . fnamemodify(getcwd(), ':~') . ' '
	return l:tablabels . ' %T%=' . l:info
endfunction
set tabline=%!g:Cuitabline()
set noexpandtab shiftwidth=0 tabstop=8
set tagcase=match tags=./tags;./../../,tags;../../
set ttimeoutlen=1
let $MYVIM = fnamemodify($MYVIMRC, ':h')
set viminfofile=$MYVIM/.viminfo directory=$MYVIM/swap
set virtualedit=block
set wildmenu wildignorecase wildmode=list:longest,full
set wrap
let g:c_comment_strings = 1
let g:vim_json_conceal = 0
let g:mapleader = ' '
let g:maplocalleader = ' '
let g:readline_has_bash = 1
let g:rust_bang_comment_leader = 1
let g:tex_conceal = ''
let g:tex_flavor = 'latex'
let g:vim_indent_cont = &tabstop
filetype plugin indent on
syntax enable

if &term == 'xterm' || has('win32')
	set t_Co=256
endif

let &t_TI = ""
let &t_TE = ""
if !s:in_screen
	call echoraw("\e[<0t\e[<s")
	let &t_SI .= "\e[<r"
	let &t_EI .= "\e[<s\e[<0t"
	let &t_te .= "\e[<0t\e[<s"
	function! g:Imzero()
		if s:autoIminsertZero
			call echoraw("\e[<0t\e[<s")
		endif
		return ''
	endfunction
	function! s:FontSizeSet(amount)
		call echoraw("\e]7770;" . a:amount . "\x7")
	endfunction
	function! s:SetScreenTitle()
	endfunction
	function! s:CopyToScreenReg(str)
	endfunction
	function! s:CopyToClip_OSC52(str)
		if a:str == ''
			return
		endif
		let l:escaped = shellescape(a:str)
		let l:enc = systemlist('echo -n ' . l:escaped . ' | base64 -w0')[0]
		call echoraw("\e]52;c;" . l:enc . "\x7")
	endfunction
else
	call echoraw("\eP\e[<0t\e[<s\e\\")
	let &t_SI .= "\eP\e[<r\e\\"
	let &t_EI .= "\eP\e[<s\e[<0t\e\\"
	let &t_te .= "\eP\e[<0t\e[<s\e\\"
	let &t_BE = "\eP\e[?2004h\e\\"
	let &t_BD = "\eP\e[?2004l\e\\"
	let &t_PS = "\e[200~"
	let &t_PE = "\e[201~"
	function! g:Imzero()
		if s:autoIminsertZero
			call echoraw("\eP\e[<0t\e[<s\e\\")
		endif
		return ''
	endfunction
	function! s:FontSizeSet(amount)
		call echoraw("\eP\e]7770;" . a:amount . "\x7\e\\")
	endfunction
	function! s:SetScreenTitle()
		call job_start(['screen', '-X', 'title', 'vim'])
	endfunction
	function! s:CopyToScreenReg(str)
		let l:escaped = escape(a:str, '\$^')
		if len(l:escaped) <= 749
			call job_start(['screen', '-X', 'register', '.', l:escaped])
		endif
	endfunction
	function! s:CopyToClip_OSC52(str)
		if a:str == ''
			return
		endif
		let l:escaped = shellescape(a:str)
		let l:enc = systemlist('echo -n ' . l:escaped . ' | base64 -w0')[0]
		if !filewritable($SCREEN_TTY)
			let $SCREEN_TTY = systemlist('screen -QX echo \$SCREEN_TTY')[0]
		endif
		call writefile(["\e]52;c;" . l:enc . "\x7"], $SCREEN_TTY, 'b')
	endfunction
		" if len(l:enc) <= 504
		" 	call echoraw("\eP\e]52;c;" . l:enc . "\x7\e\\")
		" endif
endif
if !executable('base64')
	function! s:CopyToClip_OSC52(str)
	endfunction
endif
" if executable('clip.exe')
" 	function! s:CopyToClip_clipexe(str)
" 		let l:escaped = shellescape(escape(a:str, '\'))
" 		call job_start(['/bin/sh', '-c', 'echo -n ' . l:escaped . ' | clip.exe'])
" 	endfunction
" endif
function! s:FontSizeGet()
	call <SID>FontSizeSet("?")
	for l:_ in range(7)
		call getcharstr()
	endfor
	let l:size = ""
	while 1
		let l:char = getcharstr()
		if l:char ==# "\x7"
			break
		else
			let l:size .= l:char
		endif
	endwhile
	echo l:size
endfunction
let s:pythonexe = executable('python3') ? 'python3' : 'python'

" mapping
map Y y$

nnoremap <silent> mm :<C-U>nohlsearch<CR>
nnoremap <silent> mn :<C-U>Hi0<CR>

nnoremap <silent> <C-W><C-E> :tabedit<CR>
nnoremap <silent> <C-W><C-L> :tabnext<CR>
nnoremap <silent> <C-W><C-H> :tabprevious<CR>
nnoremap <silent> <C-W><C-O> :tabonly<CR>
tnoremap <silent> <C-W><C-E> <C-W>:tabedit<CR>
tnoremap <silent> <C-W><C-L> <C-W>:tabnext<CR>
tnoremap <silent> <C-W><C-H> <C-W>:tabprevious<CR>
tnoremap <silent> <C-W><C-O> <C-W>:tabonly<CR>

nnoremap <silent> <Plug>Blankline :call append(line('.'), '')<CR>j:call repeat#set("\<Plug>Blankline")<CR>
nmap <Leader>o <Plug>Blankline

nnoremap Q gq
nnoremap <Leader>w :w<CR>
nnoremap <Leader>n :n<CR>
nnoremap <Leader>p :N<CR>
nnoremap <Leader>c :clo<CR>

function! s:ResetSearchDirection(cmd)
	let @/=@/
	nunmap n
	nunmap N
	return a:cmd
endfunction
function! s:ConsistentSearch(cmd)
	nnoremap <expr> n <SID>ResetSearchDirection('n')
	nnoremap <expr> N <SID>ResetSearchDirection('N')
	return a:cmd
endfunction
nnoremap <expr> ? <SID>ConsistentSearch('?')
nnoremap <expr> # <SID>ConsistentSearch('#')
nnoremap <expr> g# <SID>ConsistentSearch('g#')
function! s:Search(zero, word)
	if a:zero == 0
		let l:pat = '\<' . a:word . '\>'
	else
		let l:pat = a:word
	endif
	call histadd('/', l:pat)
	let @/=l:pat
	call <SID>CopyToOther(a:word)
endfunction
nnoremap <silent> <Plug>Star0 :call <SID>Search(0, expand('<cword>'))<CR>"_yiw<BS>
nnoremap <silent> <Plug>Star1 :call <SID>Search(1, expand('<cword>'))<CR>"_yiw<BS>
nmap *  <Plug>Star0n
nmap g* <Plug>Star1n
nnoremap g/ /\<\><Left><Left>

if has('win32')
	silent! vunmap <C-X>
endif

inoremap <C-U> <C-G>u<C-U>

function! g:RestoreRegister()
	silent! let @* = s:restore_reg
	silent! let @+ = s:restore_reg
	let @" = s:restore_reg
	return ''
endfunction
function! s:Repl()
	silent! let s:restore_reg = @*
	silent! let s:restore_reg = @+
	let s:restore_reg = @"
	return "p@=g:RestoreRegister()\<CR>"
endfunction
vnoremap <silent> <expr> p <SID>Repl()

function! s:Getfname()
	let l:fname = bufname() . ':' . getcurpos()[1]
	silent! let @* = l:fname
	silent! let @+ = l:fname
	call <SID>CopyToOther(l:fname)
	return l:fname
endfunction
command! Getfname echo <SID>Getfname()
nnoremap <silent> yd :<C-U>echo <SID>Getfname()<CR>

cnoremap <Left> <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>
cnoremap <Up> <C-P>
cnoremap <Down> <C-N>
cnoremap <C-A> <Home>
" cnoremap <C-O>
" cnoremap <C-B>
function! s:RegexRubout(re)
	let l:right = strpart(getcmdline(), getcmdpos() - 1)
	let l:left = strpart(getcmdline(), 0, getcmdpos() - 1)
	let l:left = substitute(l:left, a:re, '', '')
	call setcmdpos(strlen(l:left) + 1)
	return l:left . l:right
endfunction
cnoremap <Esc>/ <C-\>e<SID>RegexRubout('\v[^/ ]*/? *$')<CR>
cnoremap <C-W>  <C-\>e<SID>RegexRubout('\v([a-zA-z]+\|[0-9]+\|.) *$')<CR>
cnoremap <Esc>w <C-\>e<SID>RegexRubout('\v[^ ]* *$')<CR>
cnoremap <Esc>W <C-\>e<SID>RegexRubout('\v[^ ]* *$')<CR>

nmap ysa' ys2i'
nmap ysa" ys2i"
nmap ysa` ys2i`

nmap <Leader>0 :<C-U>Hi0<CR>
nmap <Leader>1 :<C-U>Hi1 <C-R><C-W><CR>
nmap <Leader>2 :<C-U>Hi2 <C-R><C-W><CR>
nmap <Leader>3 :<C-U>Hi3 <C-R><C-W><CR>
nmap <Leader>4 :<C-U>Hi4 <C-R><C-W><CR>
nmap <Leader>5 :<C-U>Hi5 <C-R><C-W><CR>
nmap <Leader>6 :<C-U>Hi6 <C-R><C-W><CR>

nnoremap <Leader>t :call <SID>Command({}, 1, 0, 0, ['cargo', 'test'])<CR>
nnoremap <Leader>u :call <SID>Command({}, 1, 0, 0, ['cargo', 'run'])<CR>

nnoremap <Esc>m <C-W>-
nnoremap <Esc>p <C-W>+

cnoremap <C-G> <C-\><C-N>
inoremap <C-G> <C-\><C-N>

function! s:StayColumn(cmd)
	let l:save_cursor = getcurpos()
	let l:save_cursor[4] = virtcol('.')
	call setpos('.', l:save_cursor)
	return a:cmd
endfunction
nnoremap <silent> <expr> gj <SID>StayColumn(v:count1 . 'gj')
nnoremap <silent> <expr> gk <SID>StayColumn(v:count1 . 'gk')

nnoremap <silent> <Esc>= :<C-U>call <SID>FontSizeSet("")<CR>
nnoremap <silent> <Esc>+ :<C-U>call <SID>FontSizeSet("+1")<CR>
nnoremap <silent> <Esc>- :<C-U>call <SID>FontSizeSet("-1")<CR>

function! s:Spacing(line1, line2)
	silent! execute 'keeppatterns ' . a:line1 . ',' . a:line2 . 's/\v([[:graph:]])([^ [:graph:][:cntrl:]、。])/\1 \2/g'
	silent! execute 'keeppatterns ' . a:line1 . ',' . a:line2 . 's/\v([^ [:graph:][:cntrl:]、。])([[:graph:]])/\1 \2/g'
	silent! execute 'keeppatterns ' . a:line1 . ',' . a:line2 . 's/\v([[:graph:]]) ([、。])/\1\2/g'
	silent! execute 'keeppatterns ' . a:line1 . ',' . a:line2 . 's/\v([、。]) ([[:graph:]])/\1\2/g'
endfunction
command! -range=% Spacing call <SID>Spacing(<line1>, <line2>)
nnoremap <silent> <Leader>s :call <SID>Spacing('.', '.')<CR>
vnoremap <silent> <Leader>s :call <SID>Spacing('''<', '''>')<CR>

function! s:UnSpacing(line1, line2)
	silent! execute 'keeppatterns ' . a:line1 . ',' . a:line2 . 's/\v([[:graph:]]) ([^ [:graph:][:cntrl:]])/\1\2/g'
	silent! execute 'keeppatterns ' . a:line1 . ',' . a:line2 . 's/\v([^ [:graph:][:cntrl:]]) ([[:graph:]])/\1\2/g'
endfunction
command! -range=% Unspacing call <SID>UnSpacing(<line1>, <line2>)
nnoremap <silent> <Leader>S :call <SID>UnSpacing('.', '.')<CR>
vnoremap <silent> <Leader>S :call <SID>UnSpacing('''<', '''>')<CR>

" excommand
command! DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis | wincmd p | diffthis

function! s:ReadTypescript()
	let l:ts = map(readfile('typescript')[1:-3], {_, val -> substitute(val, '\s\+$', '', '')})
	if &ft == 'c'
		let l:ts = ['/*'] + l:ts + ['*/']
	endif
	call append(getpos('.')[1], l:ts)
endfunction
command! Typesc call <SID>ReadTypescript()

command! Hitest runtime syntax/hitest.vim
command! Colortest runtime syntax/colortest.vim

command! -nargs=0 Cdhere cd %:p:h

function! s:FixWhitespace(line1, line2)
	let l:save_cursor = getcurpos()
	silent! execute 'keeppatterns ' . a:line1 . ',' . a:line2 . 's/\\\@<!\s\+$//'
	call setpos('.', l:save_cursor)
endfunction
command! -range=% FixWhitespace call <SID>FixWhitespace(<line1>, <line2>)

function! s:XXD(do)
	if a:do
		let b:save_ft_binary = [&filetype, &l:binary]
		let &binary = 1
		silent edit " for binary to take effect
		let &ft = 'xxd'
		%!xxd
	else
		if exists('b:save_ft_binary')
			let [&filetype, &l:binary] = b:save_ft_binary
			unlet b:save_ft_binary
		endif
		%!xxd -r
	endif
endfunction
command! XXD call <SID>XXD(1)
command! XXDundo call <SID>XXD(0)

function! s:MultiHlSetup()
	highlight Multihl1 ctermbg=14 ctermfg=8 guibg=#00ffff guifg=#808080
	highlight Multihl2 ctermbg=13 ctermfg=8 guibg=#ff00ff guifg=#808080
	highlight Multihl3 ctermbg=11 ctermfg=8 guibg=#ffff00 guifg=#808080
	highlight Multihl4 ctermbg=1  ctermfg=7 guibg=#800000 guifg=#c0c0c0
	highlight Multihl5 ctermbg=4  ctermfg=7 guibg=#000080 guifg=#c0c0c0
	highlight Multihl6 ctermbg=2  ctermfg=7 guibg=#008000 guifg=#c0c0c0
endfunction
function! s:Hi(num, ...)
	if a:num == 0
		call clearmatches()
	else
		silent! call matchdelete(a:num + 5)
		if a:0 != 0
			call matchadd('Multihl' . a:num, a:1, 10, a:num + 5)
			call histadd(':', 'Hi' . a:num . ' ' . a:1)
			return
		endif
	endif
	call histadd(':', 'Hi' . a:num)
endfunction
command! -nargs=0 Hi0 call <SID>Hi(0)
command! -nargs=? Hi1 call <SID>Hi(1, <f-args>)
command! -nargs=? Hi2 call <SID>Hi(2, <f-args>)
command! -nargs=? Hi3 call <SID>Hi(3, <f-args>)
command! -nargs=? Hi4 call <SID>Hi(4, <f-args>)
command! -nargs=? Hi5 call <SID>Hi(5, <f-args>)
command! -nargs=? Hi6 call <SID>Hi(6, <f-args>)

function! s:Align(cmd, line1, line2, ...)
	let l:save_cursor = getcurpos()
	if a:0 == 0
		let l:char = input('')
	else
		let l:char = a:1
	endif
	execute 'normal ' . a:line1 . 'GV' . a:line2 . 'G' . a:cmd . l:char
	call setpos('.', l:save_cursor)
endfunction
command! -range -nargs=? AlignRight call <SID>Align('gL', <line1>, <line2>, <f-args>)
command! -range -nargs=? AlignLeft  call <SID>Align('gl', <line1>, <line2>, <f-args>)

command! -nargs=0 Reload let s:undoreload = &undoreload | set undoreload=0 | edit | let &undoreload = s:undoreload

function! s:Nkf()
	let l:fname = fnamemodify(expand('%'), ':p')
	if executable('uchardet')
		let l:enc = system('uchardet ' . l:fname)
	elseif executable('nkf')
		let l:enc = system('nkf --guess=1 ' . l:fname)
	else
		echoerr 'uchardet or nkf must be installed!'
		return
	endif
	execute 'e ++enc=' . l:enc
endfunction
command! -nargs=0 Nkf call <SID>Nkf()

function! s:Command(env, reuse, focus, close, arg)
	let l:shiflag = has('win32') ? &shellcmdflag : '-ic'
	let l:cmd = &shell . ' ' . l:shiflag . ' "' . join(a:arg) . '"'
	let l:opt = {'term_rows': &lines / 4, 'term_cols': &columns - 7, 'term_kill': 'term', 'env': a:env}
	if a:close
		let l:opt['term_finish'] = 'close'
	endif
	if a:reuse
		let l:n = bufnr('!' . l:cmd)
		if l:n != -1
			execute 'bdelete ' . l:n
		endif
	endif
	call term_start(l:cmd, l:opt)
	if !a:focus
		wincmd p
	endif
endfunction
function! s:BashComp(ArgLead, CmdLine, CursorPos)
	return g:bash#complete(substitute(strpart(a:CmdLine, 0, a:CursorPos), '^\s*\a\+ ', '', ''))
endfunction
function! s:GitComp(ArgLead, CmdLine, CursorPos)
	return g:bash#complete(substitute(strpart(a:CmdLine, 0, a:CursorPos), '^\s*\a\+ ', 'git ', ''))
endfunction
if has('win32')
	command! -nargs=* -complete=file S call <SID>Command({}, 0, 0, 0, [<f-args>])
else
	command! -nargs=* -complete=customlist,<SID>BashComp S call <SID>Command({}, 0, 0, 0, [<f-args>])
	command! -nargs=* -complete=customlist,<SID>BashComp I call <SID>Command({}, 0, 1, 1, [<f-args>])
	command! -nargs=* -complete=customlist,<SID>GitComp Git call <SID>Command({'GIT_PAGER': ''}, 1, 1, 0, ['git', <f-args>])
	command! -nargs=* -complete=customlist,<SID>GitComp Gitpager call <SID>Command({}, 1, 1, 0, ['git', <f-args>])
endif

let s:template = {
	\ 'c'     : ['#include <stdio.h>', '', 'int main(void) {', '	printf("Hello\n");', '	return 0;', '}'],
	\ 'go'    : ['package main', '', 'import "fmt"', '', 'func main() {', '	fmt.Println("Hello")', '}'],
	\ 'perl'  : ['#!/usr/bin/env perl', 'use strict;', 'use warnings;'],
	\ 'python': '#!/usr/bin/env ' . s:pythonexe,
	\ 'sh'    : ['#!/usr/bin/env bash', 'set -euxo pipefail'],
	\ }
let s:template_after = {
	\ 'c' : 'call cursor(4, 2)',
	\ 'go': 'call cursor(6, 2)',
	\ '_':  'call cursor(line(''$''), 1)',
	\ }
function! s:Template()
	if has_key(s:template, &filetype)
		call append(0, s:template[&filetype])
		if getline('$') == ''
			$delete _
		endif
		if has_key(s:template_after, &filetype)
			execute(s:template_after[&filetype])
		else
			execute(s:template_after['_'])
		endif
		echon ' Template loaded'
	endif
endfunction
command! -nargs=0 Template call <SID>Template()

function! s:Sort(pat)
	let l:save_reg = @a
	normal! gv"ay
	let @a = join(sort(split(eval('@a'), a:pat)), a:pat)
	normal! gv"ap
	let @a = l:save_reg
endfunction
command! -range Sort call <SID>Sort(' ')
command! -range SortComma call <SID>Sort(', ')
command! -nargs=1 -range SortSep call <SID>Sort(<f-args>)

command! FontSizeGet call <SID>FontSizeGet()
command! FontSizeReset call <SID>FontSizeSet("")

" autocommand
command! AUTOiminsertzero let s:autoIminsertZero = !s:autoIminsertZero
let s:autoIminsertZero=0

command! AUTOhltrailingwhitespaces call <SID>ToggleAutoHlTrailingWhiteSpaces()
let s:autoHlTrailingWhiteSpaces = 1
function! s:ToggleAutoHlTrailingWhiteSpaces()
	let s:autoHlTrailingWhiteSpaces = !s:autoHlTrailingWhiteSpaces
	call <SID>HlTrailingWhiteSpace(1)
endfunction
function! s:HlTrailingWhiteSpace(isNormal)
	silent! call matchdelete(4)
	if !s:autoHlTrailingWhiteSpaces | return | endif
	if !get(b:, 'autoHlTrailingWhiteSpaces', 1) | return | endif
	if a:isNormal
		call matchadd('TrailingWhiteSpace', '\\\@<!\s\+$', 10, 4)
	else
		call matchadd('TrailingWhiteSpace', '\\\@<!\s\+\%#\@<!$', 10, 4)
	endif
endfunction

command! AUTOhlideographicspace call <SID>ToggleAutoHlIdeographicSpace()
let s:autoHlIdeographicSpace = 1
function! s:ToggleAutoHlIdeographicSpace()
	let s:autoHlIdeographicSpace = !s:autoHlIdeographicSpace
	call <SID>HlIdeographicSpace()
endfunction
function! s:HlIdeographicSpace()
	silent! call matchdelete(5)
	if !s:autoHlIdeographicSpace | return | endif
	call matchadd('IdeographicSpace', '[\u3000]', 10, 5)
endfunction

command! AUTOhalfcommas let s:autoHalfCommas = !s:autoHalfCommas
let s:autoHalfCommas = 0
function! s:HalfCommas()
	if !s:autoHalfCommas | return | endif
	let l:curpos = getcurpos()
	silent! keeppatterns %s/，\+$/\=repeat(',', strchars(submatch(0)))/g
	silent! keeppatterns %s/．\+$/\=repeat('.', strchars(submatch(0)))/g
	silent! keeppatterns %s/，\+\ze /\=repeat(',', strchars(submatch(0)))/g
	silent! keeppatterns %s/．\+\ze /\=repeat('.', strchars(submatch(0)))/g
	silent! keeppatterns %s/，\+/\=repeat(',', strchars(submatch(0))) . ' '/g
	silent! keeppatterns %s/．\+/\=repeat('.', strchars(submatch(0))) . ' '/g
	call setpos('.', l:curpos)
endfunction

command! AUTOconvertpunctuation let s:autoConvertPunctuation = !s:autoConvertPunctuation
let s:autoConvertPunctuation = 0
function! s:ConvertPunctuation()
	if !s:autoConvertPunctuation | return | endif
	let l:curpos = getcurpos()
	silent! keeppatterns %s/．/。/g
	silent! keeppatterns %s/，/、/g
	silent! keeppatterns %s/\.\.\./…/g
	" ―
	call setpos('.', l:curpos)
endfunction

function! s:CopyToOther(str)
	call <SID>CopyToScreenReg(a:str)
	call <SID>CopyToClip_OSC52(a:str)
endfunction
function! s:CopyToOtherUnnamed()
	if v:event.regname == ''
		call <SID>CopyToOther(join(v:event.regcontents, "\n"))
	endif
endfunction

augroup vimrc
	autocmd!
	autocmd BufRead,BufNewFile * if &ft == 'asm' | set ft=gas | endif
	autocmd BufRead,BufNewFile *.lalrpop set ft=rust
	autocmd BufRead,BufNewFile */git/config set ft=gitconfig
	autocmd BufRead,BufNewFile */yapf/style set ft=cfg
	autocmd BufRead,BufNewFile .latexmkrc,latexmkrc set ft=perl
	autocmd BufRead,BufNewFile .clang-format set ft=yaml
	autocmd BufReadPost * if line('''"') >= 1 && line('''"') <= line('$') && &ft !~# 'commit' | execute 'normal! g`"' | endif
	autocmd StdinReadPost * set nomodified
	autocmd CmdwinEnter * nnoremap <buffer> <F5> :let g:CmdwinLastLineNum=line('.')<CR><CR>q::execute g:CmdwinLastLineNum<CR>
	autocmd Colorscheme * highlight Cursor guifg=fg guibg=Red
	autocmd Colorscheme * highlight CursorIM guifg=Black guibg=Blue
	autocmd Colorscheme * highlight TabLineFill guibg=#808080
	autocmd ColorScheme * highlight TrailingWhiteSpace ctermbg=darkred guibg=darkred
	autocmd Colorscheme * highlight IdeographicSpace term=underline ctermbg=DarkGreen guibg=DarkGreen

	autocmd BufEnter,BufRead,BufNew * call <SID>HlTrailingWhiteSpace(1)
	autocmd InsertLeave * call <SID>HlTrailingWhiteSpace(1)
	autocmd InsertEnter * call <SID>HlTrailingWhiteSpace(0)
	autocmd BufEnter,BufRead,BufNew * call <SID>HlIdeographicSpace()
	autocmd Colorscheme * call <SID>MultiHlSetup()
	autocmd BufNewFile *.go,*.pl,*.py,*.sh call <SID>Template()
	autocmd BufWritePre *.tex call <SID>HalfCommas()
	autocmd BufWritePre *.txt call <SID>ConvertPunctuation()
	autocmd TextYankPost * call <SID>CopyToOtherUnnamed()
	autocmd VimResume * call <SID>SetScreenTitle()
augroup END

" pack
function! s:Minpac()
	if !exists('*minpac#init')
		call system('git clone --depth 1 -- https://github.com/hayatogh/minpac.git ~/.vim/pack/minpac/opt/minpac')
		packadd minpac
	endif
	call minpac#init({'jobs': 4, 'autoyes': 1})
	call minpac#add('hayatogh/minpac', {'type': 'opt'})

	call minpac#add('tpope/vim-commentary')
	call minpac#add('vim-jp/vimdoc-ja')
	call minpac#add('editorconfig/editorconfig-vim', {'submodule': 0})
	call minpac#add('mattn/emmet-vim', {'submodule': 0})
	call minpac#add('tpope/vim-eunuch')
	call minpac#add('cohama/lexima.vim')
	call minpac#add('tommcdo/vim-lion')
	call minpac#add('scrooloose/nerdtree')
	call minpac#add('luochen1990/rainbow')
	call minpac#add('hayatogh/vim-surround')
	call minpac#add('kana/vim-tabpagecd')
	call minpac#add('guns/xterm-color-table.vim')
	" external commands
	call minpac#add('dense-analysis/ale')
	call minpac#add('HiPhish/info.vim')
	call minpac#add('thinca/vim-quickrun')
	" libraries
	call minpac#add('kana/vim-operator-user')
	call minpac#add('kana/vim-textobj-indent')
	call minpac#add('kana/vim-textobj-user')
	call minpac#add('hayatogh/vim-bash-completion')
	call minpac#add('tpope/vim-repeat')
	call minpac#add('tyru/open-browser.vim')
	" colorscheme
	call minpac#add('tomasr/molokai')
	" syntax and filetype plugins
	call minpac#add('kchmck/vim-coffee-script')
	call minpac#add('chrisbra/csv.vim')
	call minpac#add('Shirk/vim-gas')
	call minpac#add('tpope/vim-markdown')
	call minpac#add('previm/previm')
	call minpac#add('vim-python/python-syntax')
	call minpac#add('wlangstroth/vim-racket')
	call minpac#add('lervag/vimtex')
	call minpac#add('cespare/vim-toml')
	call minpac#clean()
	call minpac#update()
endfunction
command! MinLoad silent! source $MYVIMRC | call <SID>Minpac()
" previm
let g:previm_enable_realtime = 1
let g:loaded_previm = 1
command! -nargs=0 PrevimOpen unlet g:loaded_previm | runtime plugin/previm.vim | doautocmd Previm FileType | PrevimOpen
" vimtex
if has('win32')
	let g:vimtex_view_general_viewer = 'SumatraPDF'
	let g:vimtex_view_general_options_latexmk = '-reuse-instance'
	let g:vimtex_view_general_options = '-reuse-instance -forward-search @tex @line @pdf'
endif
" lexima
let g:lexima_no_default_rules = 1
let g:lexima_map_escape=''
" quickrun
nmap <Leader>r <Plug>(quickrun)
let g:quickrun_config = {
	\ 'python': {
	\   'command': s:pythonexe
	\ },
	\ 'rust': {
	\   'command': 'runner',
	\   'exec': '%c %s %o',
	\ },
	\ 'scheme': {
	\   'command': 'chezscheme',
	\   'exec': '%c --script %s',
	\ },
	\ '_': {
	\   'outputter/buffer/opener': 'botright new',
	\   'outputter/buffer/close_on_empty': 1,
	\   'runner': 'terminal',
	\ },
	\ }
if has('win32')
	let g:quickrun_config.scheme = {
		\ 'command': 'C:\Program Files\Racket\mzscheme.exe',
		\ 'exec': '%c %o -e ''(load "%s")'' %a',
		\ }
elseif has('osxdarwin')
	let g:quickrun_config.scheme.command = 'chez'
endif
" ale
nmap <Leader>j <Plug>(ale_next)
nmap <Leader>k <Plug>(ale_previous)
nmap <Leader>h <Plug>(ale_detail)

function! s:ALEFixOnSaveToggle(vartype, value)
	let l:new = a:value == -1 ? '!' . get(eval(a:vartype . ':'), 'ale_fix_on_save', 0) : a:value
	execute 'let ' . a:vartype . ':ale_fix_on_save = ' . l:new
endfunction
command! -bar ALEFixOnSaveToggle        call <SID>ALEFixOnSaveToggle('g', -1)
command! -bar ALEFixOnSaveToggleBuffer  call <SID>ALEFixOnSaveToggle('b', -1)
command! -bar ALEFixOnSaveEnable        call <SID>ALEFixOnSaveToggle('g', 1)
command! -bar ALEFixOnSaveEnableBuffer  call <SID>ALEFixOnSaveToggle('b', 1)
command! -bar ALEFixOnSaveDisable       call <SID>ALEFixOnSaveToggle('g', 0)
command! -bar ALEFixOnSaveDisableBuffer call <SID>ALEFixOnSaveToggle('b', 0)
command! -bar ALEEnableAll        ALEEnable | ALEFixOnSaveEnable
command! -bar ALEEnableAllBuffer  ALEEnableBuffer | ALEFixOnSaveEnableBuffer
command! -bar ALEDisableAll       ALEDisable | ALEFixOnSaveDisable
command! -bar ALEDisableAllBuffer ALEDisableBuffer | ALEFixOnSaveDisableBuffer

function! s:TGuess(pattern, flags, info)
	if !has_key(a:info, 'buf_ffname')
		return v:null
	endif
	if a:flags == 'c'
		let l:pat = '^' . a:pattern . '$'
	elseif a:flags == 'i'
		let l:pat = '^' . a:pattern . '.*'
	else
		let l:pat = a:pattern
	endif
	let l:tags = filter(taglist(l:pat), 'get(v:val, ''kind'', '''') != ''p''')
	if len(l:tags) == 1
		echom 'Jump to the only'
		return [l:tags[0]]
	endif
	let l:file = fnamemodify(a:info['buf_ffname'], ':.')
	let l:current = filter(copy(l:tags), 'v:val[''filename''] == l:file')
	if len(l:current) == 1
		echom 'Jump to the only current'
		return [l:current[0]]
	elseif len(l:current) > 1
		return v:null
	endif
	let l:dir = fnamemodify(l:file, ':h')
	let l:siblings = filter(copy(l:tags), 'fnamemodify(v:val[''filename''], '':h'') == l:dir')
	if len(l:siblings) == 1
		echom 'Jump to the only sibling'
		return [l:siblings[0]]
	endif
	return v:null
endfunction
function! s:Tjump(sp, guess)
	if tagfiles() == []
		return ":ALEGoToDefinition" . (a:sp ? ' -split' : '') . "\<CR>"
	else
		if a:guess
			setl tagfunc=<SID>TGuess
		else
			setl tagfunc=
		endif
		return (a:sp ? "\<C-W>" : '') . "g\<C-]>"
	endif
endfunction
nnoremap <expr> g<C-]>      <SID>Tjump(0, 0)
vnoremap <expr> g<C-]>      <SID>Tjump(0, 0)
nnoremap <expr> g]          <SID>Tjump(0, 0)
vnoremap <expr> g]          <SID>Tjump(0, 0)
nnoremap <expr> <C-]>       <SID>Tjump(0, 1)
vnoremap <expr> <C-]>       <SID>Tjump(0, 1)
nnoremap <expr> <C-W>g<C-]> <SID>Tjump(1, 0)
vnoremap <expr> <C-W>g<C-]> <SID>Tjump(1, 0)
nnoremap <expr> <C-W>g]     <SID>Tjump(1, 0)
vnoremap <expr> <C-W>g]     <SID>Tjump(1, 0)
nnoremap <expr> <C-W><C-]>  <SID>Tjump(1, 1)
vnoremap <expr> <C-W><C-]>  <SID>Tjump(1, 1)
nnoremap <expr> <C-W>]      <SID>Tjump(1, 1)
vnoremap <expr> <C-W>]      <SID>Tjump(1, 1)

let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
let g:ale_linters = {
	\ 'asciidoc' : ['vale'],
	\ 'c'        : ['clangd'],
	\ 'cpp'      : ['clangd'],
	\ 'go'       : ['govet', 'gopls'],
	\ 'mail'     : ['vale'],
	\ 'markdown' : ['vale'],
	\ 'ocaml'    : ['ocamllsp'],
	\ 'python'   : ['pylsp'],
	\ 'rst'      : ['vale'],
	\ 'rust'     : ['rls', 'cargo'],
	\ 'tex'      : ['chktex'],
	\ }
let g:ale_fixers = {
	\ 'c'     : ['clang-format'],
	\ 'cpp'   : ['clang-format'],
	\ 'go'    : ['gofmt', 'goimports'],
	\ 'ocaml' : ['ocamlformat'],
	\ 'python': ['isort', 'yapf'],
	\ 'rust'  : ['rustfmt'],
	\ }
let g:ale_c_clangformat_style_option = '{ BasedOnStyle: LLVM, IndentWidth: 4 }'
let g:ale_c_clangformat_use_local_file = 1
let g:ale_rust_cargo_use_clippy = executable('cargo-clippy')
let g:ale_completion_enabled = 1
let g:ale_fix_on_save = 1
let g:ale_hover_cursor = 0
let g:ale_lint_on_text_changed = 0
let g:ale_lint_on_insert_leave = 0
let g:ale_virtualtext_cursor = 0
if has('win32unix')
	let g:ale_enabled = 0
endif
" vim-markdown
let g:markdown_fenced_languages = ['html', 'python', 'bash=sh', 'c', 'cpp']
" vim-surround
let g:surround_dict = {
	\ 'U' : 'https://\r/',
	\ 'mk': '「\r」',
	\ 'mn': '『\r』',
	\ 'mb': '（\r）',
	\ 'ms': '【\r】',
	\ 'ma': '［\r］',
	\ }
" NERDTree
let g:NERDTreeMapActivateNode = 'e'
let g:NERDTreeMapOpenSplit = 's'
let g:NERDTreeMapOpenVSplit = 'v'
" openbrowser
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)
nmap gX :<C-U>call openbrowser#search(expand('<cword>'), 'x')<CR>
vmap gX :<C-U>call openbrowser#search(expand('<cword>'), 'x')<CR>
let g:openbrowser_default_search = 'bing'
let g:openbrowser_search_engines = {
	\ 'bing': 'https://www.bing.com/search?q={query}',
	\ 'x':    'https://www.oxfordlearnersdictionaries.com/search/english/?q={query}',
	\ }
" global
if filereadable('/usr/local/share/gtags/gtags.vim')
	source /usr/local/share/gtags/gtags.vim
elseif filereadable('/usr/share/vim/addons/plugin/gtags.vim')
	source /usr/share/vim/addons/plugin/gtags.vim
elseif filereadable('/usr/share/gtags/gtags.vim')
	source /usr/share/gtags/gtags.vim
endif
" rainbow vim-gas vim-lion emmet python-syntax csv
let g:rainbow_active = 1
let g:gasCppComments = 1
let g:lion_squeeze_spaces = 1
let g:user_emmet_leader_key='<C-K>'
let g:python_highlight_all = 1
let g:csv_default_delim=','

packloadall!
packadd matchit
silent! packadd termdebug
silent! packadd minpac
runtime ftplugin/man.vim
" lexima
function! s:LeximaEndwise(at, end, filetype)
	return {'char': '<CR>', 'input': '<CR>', 'input_after': '<CR>' . a:end, 'at': a:at, 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . a:end, 'filetype': a:filetype}
endfunction
let s:rulelist = [
	\ {'char': '<CR>', 'at': '(\%#)',   'input_after': '<CR>'},
	\ {'char': '<CR>', 'at': '{\%#}',   'input_after': '<CR>'},
	\ {'char': '<CR>', 'at': '\[\%#\]', 'input_after': '<CR>'},
	\ <SID>LeximaEndwise('^\s*if\>.*\%#$',         'endif',       'vim'),
	\ <SID>LeximaEndwise('^\s*while\>.*\%#$',      'endwhile',    'vim'),
	\ <SID>LeximaEndwise('^\s*for\>.*\%#$',        'endfor',      'vim'),
	\ <SID>LeximaEndwise('^\s*try\>.*\%#$',        'endtry',      'vim'),
	\ <SID>LeximaEndwise('^\s*function!.*\%#$',    'endfunction', 'vim'),
	\ <SID>LeximaEndwise('^\s*augroup\s\+.\+\%#$', 'augroup END', 'vim'),
	\ <SID>LeximaEndwise('^\s*\%(module\|def\|class\|if\|unless\|for\|while\|until\|case\)\>\%(.*[^.:@$]\<end\>\)\@!.*\%#$', 'end', 'ruby'),
	\ <SID>LeximaEndwise('^\s*\%(begin\)\s*\%#$',                                                                            'end', 'ruby'),
	\ <SID>LeximaEndwise('\%(^\s*#.*\)\@<!do\%(\s*|.*|\)\?\s*\%#$',                                                          'end', 'ruby'),
	\ <SID>LeximaEndwise('\<\%(if\|unless\)\>.*\%#$',                                                                        'end', 'ruby'),
	\ <SID>LeximaEndwise('\%(^\s*#.*\)\@<!do\s*\%#$', 'end', 'elixir'),
	\ <SID>LeximaEndwise('^\s*if\>.*\%#$',             'fi',   ['sh', 'zsh']),
	\ <SID>LeximaEndwise('^\s*case\>.*\%#$',           'esac', ['sh', 'zsh']),
	\ <SID>LeximaEndwise('\%(^\s*#.*\)\@<!do\>.*\%#$', 'done', ['sh', 'zsh']),
	\ <SID>LeximaEndwise('\%(^\s*#.*\)\@<!\<\%(module\|struct\|function\|if\|for\|while\|do\|let\|macro\)\>\%(.*\<end\>\)\@!.*\%#$', 'end', 'julia'),
	\ <SID>LeximaEndwise('\%(^\s*#.*\)\@<!\s*\<\%(begin\|try\|quote\)\s*\%#$',                                                       'end', 'julia'),
	\ {'char': '<CR>', 'input': '<CR>'},
	"\ inoremap <CR> <C-G>u<CR>
	\ ]
delfunction s:LeximaEndwise
for s:rule in s:rulelist
	silent! call lexima#add_rule(s:rule)
endfor
unlet s:rule s:rulelist
" vim-surround
let s:surround_textobj = {
	\ 'surround-mk': {'pattern': ['「', '」'], 'select-a': 'amk', 'select-i': 'imk'},
	\ 'surround-mn': {'pattern': ['『', '』'], 'select-a': 'amn', 'select-i': 'imn'},
	\ 'surround-mb': {'pattern': ['（', '）'], 'select-a': 'amb', 'select-i': 'imb'},
	\ 'surround-ms': {'pattern': ['【', '】'], 'select-a': 'ams', 'select-i': 'ims'},
	\ 'surround-ma': {'pattern': ['［', '］'], 'select-a': 'ama', 'select-i': 'ima'},
	\ }
silent! call textobj#user#plugin('surround', s:surround_textobj)
unlet s:surround_textobj

" gui
if has("gui_running") && has('win32')
	set guifont=Consolas:h11
	set lines=30 columns=86
	let s:gvim_winpos_file = expand('~/.gvimwinpos')
	function! s:SaveGVimPos()
		let l:pos = [getwinposx(), getwinposy()]
		call writefile(l:pos, s:gvim_winpos_file)
	endfunction
	augroup vimrc
		autocmd VimLeavePre * call <SID>SaveGVimPos()
	augroup END
	if filereadable(s:gvim_winpos_file)
		let s:pos = readfile(s:gvim_winpos_file)
		let s:n = str2nr(strpart(v:servername, 4))
		execute 'winpos ' . (s:pos[0] + 32 * s:n) . ' ' . (s:pos[1] + 32 * s:n)
		unlet s:pos s:n
	endif
	function! g:Imzero()
		if s:autoIminsertZero
			set iminsert=0
		endif
		return ''
	endfunction
	function! s:FontSizeSet(amount)
		let l:font = split(split(&guifont, '[^\\]\zs,')[0], '[^\\]\zs:')
		let l:size = l:font[1][1:]
		if !exists('s:guifont_default_size')
			let s:guifont_default_size = l:size
		endif
		if a:amount ==# ""
			let l:size = s:guifont_default_size
		else
			let l:size = eval(l:size . a:amount)
		endif
		let l:font[1] = l:font[1][0] . l:size
		let &guifont = join(l:font, ':')
	endfunction
	function! s:CopyToClip_OSC52(str)
	endfunction

	nnoremap <silent> <M-Space> :simalt ~<CR>
	cnoremap <M-/> <C-\>e<SID>RegexRubout('\v[^/\\]*(/\|\\)? *$')<CR>
	cnoremap <M-w> <C-\>e<SID>RegexRubout('\v[^ ]* *$')<CR>
	nnoremap <M-m> <C-W>-
	nnoremap <M-p> <C-W>+
	nnoremap <silent> <M-=>               :<C-U>call <SID>FontSizeSet("")<CR>
	nnoremap <silent> <M-+>               :<C-U>call <SID>FontSizeSet("+1")<CR>
	nnoremap <silent> <M-->               :<C-U>call <SID>FontSizeSet("-1")<CR>
	nnoremap <silent> <C-=>               :<C-U>call <SID>FontSizeSet("")<CR>
	nnoremap <silent> <C-ScrollWheelUp>   :<C-U>call <SID>FontSizeSet("+1")<CR>
	nnoremap <silent> <C-ScrollWheelDown> :<C-U>call <SID>FontSizeSet("-1")<CR>
endif

if filereadable(expand('~/.localvimrc.vim'))
	source ~/.localvimrc.vim
endif
silent! colorscheme molokai
